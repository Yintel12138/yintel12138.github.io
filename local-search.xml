<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cpp Scavenging</title>
    <link href="/2024/09/11/Cpp-Scavenging/"/>
    <url>/2024/09/11/Cpp-Scavenging/</url>
    
    <content type="html"><![CDATA[<p>复习目标：</p><ul><li>函数&#x2F;运算符重载</li><li>虚函数与抽象类</li><li>内存模型</li><li>OOP 相关（封装继承多态）</li><li>指针（原始指针）</li><li>动态内存分配与释放</li><li>引用 （右值引用、完美转发）</li><li>字符串处理</li><li>模版</li><li>友元</li></ul><p>输出：</p><ul><li>博客 1-3 篇</li></ul><h3 id="1-函数-运算符重载"><a href="#1-函数-运算符重载" class="headerlink" title="1. 函数&#x2F;运算符重载"></a>1. 函数&#x2F;运算符重载</h3><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的<strong>参数列表和定义（实现）不相同</strong>。</p><p><strong>函数重载</strong>比较简单，但是需要注意的是，区分重载函数的是参数列表，返回值不作为判断的标准。两个函数如果只有返回值类型不同，而参数列表相同，是<strong>不能构成重载</strong>的，会发生：会出现编译错误，提示函数重载冲突，因为编译器无法仅通过返回值类型来区分这两个函数。</p><p><strong>运算符重载</strong>稍微有点复杂。可以重定义或重载大部分 C++ 内置的运算符，重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义为成员函数</span><br>Box <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Box&amp;);<br><span class="hljs-comment">// 定义上面的函数为类的非成员函数</span><br>Box <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Box&amp;, <span class="hljs-type">const</span> Box&amp;);<br></code></pre></td></tr></table></figure><p>具体的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Box <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Box&amp; b)<br>&#123;<br>   Box box;<br>   box.length = <span class="hljs-keyword">this</span>-&gt;length + b.length;<br>   box.breadth = <span class="hljs-keyword">this</span>-&gt;breadth + b.breadth;<br>   box.height = <span class="hljs-keyword">this</span>-&gt;height + b.height;<br>   <span class="hljs-keyword">return</span> box;<br>&#125;<br><span class="hljs-comment">// 把两个对象相加，得到 Box3</span><br>Box3 = Box1 + Box2;<br></code></pre></td></tr></table></figure><p>哪些能够重载，哪些不能重载？<br>可重载的：<br>![[Pasted image 20240911181705.png]]</p><p>下面是不可重载的运算符列表：</p><ul><li>.：成员访问运算符</li><li>.*, -&gt;*：成员指针访问运算符</li><li>::：域运算符</li><li>sizeof：长度运算符</li><li>?:：条件运算符</li><li><code>#</code> 预处理符号</li></ul><p>一个🌰—重载前缀&#x2F;后缀 <code>++</code>，注意体会他们的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 重载前缀递增运算符（ ++ ）</span><br>Time <span class="hljs-keyword">operator</span>++ ()  <br>&#123;<br>   ++minutes;          <span class="hljs-comment">// 对象加 1</span><br>   <span class="hljs-keyword">if</span>(minutes &gt;= <span class="hljs-number">60</span>)  <br>   &#123;<br>      ++hours;<br>      minutes -= <span class="hljs-number">60</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Time</span>(hours, minutes);<br>&#125;<br><span class="hljs-comment">// 重载后缀递增运算符（ ++ ）</span><br>Time <span class="hljs-keyword">operator</span>++( <span class="hljs-type">int</span> )       <br>&#123;<br>   <span class="hljs-comment">// 保存原始值</span><br>   <span class="hljs-function">Time <span class="hljs-title">T</span><span class="hljs-params">(hours, minutes)</span></span>;<br>   <span class="hljs-comment">// 对象加 1</span><br>   ++minutes;                  <br>   <span class="hljs-keyword">if</span>(minutes &gt;= <span class="hljs-number">60</span>)<br>   &#123;<br>      ++hours;<br>      minutes -= <span class="hljs-number">60</span>;<br>   &#125;<br>   <span class="hljs-comment">// 返回旧的原始值</span><br>   <span class="hljs-keyword">return</span> T; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-虚函数与抽象类"><a href="#2-虚函数与抽象类" class="headerlink" title="2. 虚函数与抽象类"></a>2. 虚函数与抽象类</h3><p>使用关键字 <code>virtual</code> 在基类中声明虚函数，主要用于实现多态性。</p><p>编译器为包含虚函数的类创建一个虚函数表（V-Table）。每个对象包含一个指向虚函数表的指针（V-Ptr）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 虚函数</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><br><span class="hljs-comment">// 派生类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived1</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 重写虚函数</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived1 class&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 派生类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived2</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 重写虚函数</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived2 class&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 派生类3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived3</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 重写虚函数</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived3 class&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; obj)</span> </span>&#123;<br>    obj.<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 调用实际对象的show函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base base;<br>    Derived1 derived1;<br>    Derived2 derived2;<br>    Derived3 derived3;<br><br>    <span class="hljs-built_in">display</span>(base);    <span class="hljs-comment">// 调用Base::show</span><br>    <span class="hljs-built_in">display</span>(derived1); <span class="hljs-comment">// 调用Derived1::show</span><br>    <span class="hljs-built_in">display</span>(derived2); <span class="hljs-comment">// 调用Derived2::show</span><br>    <span class="hljs-built_in">display</span>(derived3); <span class="hljs-comment">// 调用Derived3::show</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>![[Pasted image 20240911194924.png]]</p><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>示意图</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs md">+------------------+<br>|    代码区        |<br>+------------------+<br>|    常量区        |<br>+------------------+<br>| 全局/静态区       |<br>+------------------+<br>|       堆         |<br>| (向上增长)        |<br>+------------------+<br>|       栈         |<br>| (向下增长)        |<br>+------------------+<br></code></pre></td></tr></table></figure><ol><li>Stack：存储<strong>局部变量</strong>和<strong>函数调用</strong>的相关信息，通常是自动管理，速度较快</li><li>Heap：用于动态分配内存，通过 new 和 delete 进行管理，速度较慢</li><li>Global&#x2F;Static Area：生命周期长，存放全局变量和静态变量，在<strong>程序开始时进行初始化</strong></li><li>Constant Area：存储常量数据，包括字符串字面量和 const 常量，通常是只读的，并且可以共享<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure></li></ol><p>const int constVar &#x3D; 30; &#x2F;&#x2F; 常量变量<br>const char* str &#x3D; “Hello, World!”; &#x2F;&#x2F; 字符串字面量<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">5.</span> Code Area：代码区用于存储程序的可执行代码。代码区通常是只读的，防止程序意外修改代码。**共享**：代码区可以在多个进程之间共享，以节省内存。<br><br>```cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量（栈）</span><br>    <span class="hljs-type">int</span> localVar = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-comment">// 静态变量（全局/静态区）</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">// 动态分配内存（堆）</span><br>    <span class="hljs-type">int</span>* heapVar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">40</span>);<br><br>    <span class="hljs-comment">// 常量变量（常量区）</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> constVar = <span class="hljs-number">50</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Global Variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Local Variable: &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Static Variable: &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Heap Variable: &quot;</span> &lt;&lt; *heapVar &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Constant Variable: &quot;</span> &lt;&lt; constVar &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 释放堆内存</span><br>    <span class="hljs-keyword">delete</span> heapVar;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">function</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>受限主机通过ssh的socks5代理访问其他计算机网络的方法</title>
    <link href="/2024/06/17/ssh-with-socks5/"/>
    <url>/2024/06/17/ssh-with-socks5/</url>
    
    <content type="html"><![CDATA[<h1 id="注：本文只讨论技术，其他与本文无关"><a href="#注：本文只讨论技术，其他与本文无关" class="headerlink" title="!!!注：本文只讨论技术，其他与本文无关"></a>!!!注：本文只讨论技术，其他与本文无关</h1><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>访问某些网络受限的计算机A<br>可访问某些网络受限的计算机B<br>公网服务器C</p><h3 id="方法原理"><a href="#方法原理" class="headerlink" title="方法原理"></a>方法原理</h3><p>本方法基于SSH提供的反向代理隧道功能，配合frp（Fast Reverse Proxy）服务，在网络受限的场景下实现计算机A与计算机B间的安全连接。SSH反向隧道能够让位于内网的计算机B主动建立连接到公网服务器C，并将请求转发到计算机A，实现远程访问的目的。frp服务作为内网穿透的工具，进一步增强了连接的稳定性和灵活性。</p><h3 id="具体实现过程"><a href="#具体实现过程" class="headerlink" title="具体实现过程"></a>具体实现过程</h3><ol><li>在计算机B和公网服务器C上配置frp内网穿透服务<ul><li>在公网服务器C上部署frp服务端。</li><li>在计算机B上部署frp客户端，配置好对应服务端的连接信息，以确保B可以通过C转发请求。</li></ul></li><li>计算机A通过ssh经过C的frp转发，连接到B<ul><li><code>ssh -D 1080 -p 2222 user@serverC</code></li></ul></li><li>在A上配置socks5s代理（可使用proxychain完成，即插即用）<ul><li>利用ProxyChains或类似工具，配置代理为<code>socks5 127.0.0.1 1080</code>，可以让计算机A上的流量通过计算机B访问网络。</li></ul></li></ol><h3 id="带宽瓶颈分析"><a href="#带宽瓶颈分析" class="headerlink" title="带宽瓶颈分析"></a>带宽瓶颈分析</h3><ul><li>带宽瓶颈主要受公网服务器C的网络带宽和计算机A、B之间的网络质量限制。</li><li>反向代理和Socks5代理会引入额外的网络延迟，对于大量数据的传输和要求高响应速度的应用，性能可能受到影响。</li></ul><h3 id="安全性能分析"><a href="#安全性能分析" class="headerlink" title="安全性能分析"></a>安全性能分析</h3><ul><li>使用SSH隧道和frp服务，整个通信过程都是加密的，提高了数据传输的安全性。</li><li>需要妥善保管公网服务器C的访问凭证，以防遭到未授权访问。</li><li>定期更新SSH和frp相关软件，应用安全补丁以防范潜在的安全风险。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了利用SSH反向代理隧道和frp内网穿透服务，在网络受限的情况下实现远程连接计算机A与计算机B的方法。该方案在提供跨网络连接的同时，也保证了通信的安全性。然而，需要注意网络带宽和延迟对性能的影响，并妥善管理安全凭证和更新维护相关软件。这种方式为许多需要远程工作和数据传输的场景提供了一种有效的解决方案。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ssh</tag>
      
      <tag>网络折腾</tag>
      
      <tag>socks5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法能力提升计划 Algorithm Capability Enhancement Program</title>
    <link href="/2024/04/01/Algorithm-Improve/"/>
    <url>/2024/04/01/Algorithm-Improve/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：<br>督促自己学习，顺便记录题解</p></blockquote><h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><ul><li>5&#x2F;19 更新<a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a>、<a href="https://leetcode.cn/problems/n-queens-ii/">52. N 皇后 II</a>、<a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a>、<a href="https://leetcode.cn/problems/interleaving-string/">97. 交错字符串</a>（昨天尸体不舒服，所以没做，哈哈哈给自己找了个借口，不过今天补上）</li><li>5&#x2F;17 更新<a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a>、<a href="https://leetcode.cn/problems/game-of-life/">289. 生命游戏</a></li><li>5&#x2F;16 更新<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a>、<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></li><li>5&#x2F;15 更新<a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>、<a href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></li><li>5&#x2F;14 更新<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a>、<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></li><li>5&#x2F;13 更新<a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a>、<a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></li><li>5&#x2F;11 更新<a href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a>、<a href="https://leetcode.cn/problems/snakes-and-ladders/">909. 蛇梯棋</a>（感觉有点懈怠了，现在刷题有种例行公事的感觉，没有当初的那种激情了）</li><li>5&#x2F;10 更新<a href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a>、<a href="https://leetcode.cn/problems/clone-graph/">133. 克隆图</a></li><li>5&#x2F;9 更新<a href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a>、<a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a>（重温一下岛屿数量，经典dfs）</li><li>5&#x2F;8 更新<a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a>、<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>、<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a>、<a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a>（今天全是层序遍历）</li><li>5&#x2F;7 更新<a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>、<a href="https://leetcode.cn/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a>（二叉树的部分终于完结了<em>★,°</em>:.☆(￣▽￣)&#x2F;$:<em>.°★</em> 。）</li><li>5&#x2F;6 更新<a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a>、<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>（今天这个第一个题有点难度，理解了半天，coze也不是完全靠谱呀）</li><li>5&#x2F;5 更新<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a>、<a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a>（这两道题的思路基本一样，所以做一个就能做另一个）</li><li>5&#x2F;4 更新<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a>、<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a>（五一给自己放了个假~看来复习的事情要提上日程了，看了最开始做的题，已经不知道怎么做了……）</li><li>4&#x2F;30 更新<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>、<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></li><li>4&#x2F;29 更新<a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a>、<a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a>（对二叉树的理解还是不够，还是得好好复习）</li><li>4&#x2F;28 更新<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>、<a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a>（今天开始做一些二叉树的题目，适时可以看看之前的数据结构PPT）</li><li>4&#x2F;27 更新<a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a>、<a href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a>（今天感觉有点懈怠了，请继续加油！人在做，天在看）</li><li>4&#x2F;26 更新<a href="https://leetcode.cn/problems/simplify-path/">71. 简化路径</a>、<a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></li><li>4&#x2F;25 更新<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a>、<a href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></li><li>4&#x2F;24 更新🌟<a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>、🌟<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></li><li>4&#x2F;23 更新<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>、<a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a>、🌟<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a>、<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>（堆和动态规划）</li><li>4&#x2F;22 更新<a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a>、<a href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></li><li>4&#x2F;21 更新<a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a>、<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></li><li>4&#x2F;20 更新<a href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和</a>、<a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></li><li>4&#x2F;19 更新<a href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数</a>、<a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/">201. 数字范围按位与</a>（位运算）、<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a>、<a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></li><li>4&#x2F;18 更新<a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a>、<a href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a></li><li>4&#x2F;17 更新<a href="https://leetcode.cn/problems/reverse-bits/">190. 颠倒二进制位</a>、<a href="https://leetcode.cn/problems/add-binary/">67. 二进制求和</a></li><li>4&#x2F;16 更新<a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a>、<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a>、<a href="https://leetcode.cn/problems/combinations/">77. 组合</a>、<a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a>、<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a>、<a href="https://leetcode.cn/problems/permutations/">46. 全排列</a>（回溯day~）</li><li>4&#x2F;15 更新<a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a>、<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a>（有点没有带脑子）</li><li>4&#x2F;14 更新<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>、<a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a>（生病了leetcode也不能停！）</li><li>4&#x2F;13 更新<a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a>、<a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></li><li>4&#x2F;12 更新<a href="https://leetcode.cn/problems/summary-ranges/">228. 汇总区间</a>、<a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></li><li>4&#x2F;11 更新<a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a>、<a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></li><li>4&#x2F;10 更新<a href="https://leetcode.cn/problems/word-pattern/">290. 单词规律</a>、<a href="https://leetcode.cn/problems/isomorphic-strings/">205. 同构字符串</a>、<a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a>（三个easy）</li><li>4&#x2F;9 更新<a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a>、<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></li><li>4&#x2F;8 更新<a href="https://leetcode.cn/problems/max-points-on-a-line/">149. 直线上最多的点数</a>、<a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a>、<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a>、<a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></li><li>4&#x2F;7 更新<a href="https://leetcode.cn/problems/h-index/">274. H 指数</a>、<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>、<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></li><li>4&#x2F;3 更新<a href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和</a></li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>（手动更新好累，暂时不更新了吧~）</p><h3 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加与搜索单词 - 数据结构设计</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordDictionary</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>            self.children = &#123;&#125;<br>            self.isEndOfWord = <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 这个题目应该是要使用字典树来实现的</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.root = self.TrieNode()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addWord</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = self.root<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:<br>                node.children[char] = self.TrieNode()<br>            node = node.children[char]<br>        node.isEndOfWord = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 使用dfs进行遍历</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node: self.TrieNode, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(word):<br>                <span class="hljs-keyword">return</span> node.isEndOfWord<br>            <span class="hljs-keyword">if</span> word[i] == <span class="hljs-string">&#x27;.&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">any</span>(dfs(child, i+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children.values())<br>            <span class="hljs-keyword">if</span> word[i] <span class="hljs-keyword">in</span> node.children:<br>                <span class="hljs-keyword">return</span> dfs(node.children[word[i]], i+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> dfs(self.root, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="52-N-皇后-II"><a href="#52-N-皇后-II" class="headerlink" title="52. N 皇后 II"></a><a href="https://leetcode.cn/problems/n-queens-ii/">52. N 皇后 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># N 皇后 II</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">totalNQueens</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 经典dfs问题</span><br>    <span class="hljs-comment"># 需要创建visit数组（这里不固定所以很难做到）</span><br>    <span class="hljs-comment"># 通过比较对角线上的和和差判断是否冲突</span><br>    result = [<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">queens, xyDiff, xySum</span>):<br>        p = <span class="hljs-built_in">len</span>(queens)<br>        <span class="hljs-keyword">if</span> p == n:<br>            result[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> queens <span class="hljs-keyword">and</span> p-q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> xyDiff <span class="hljs-keyword">and</span> p+q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> xySum:<br>                dfs(queens + [q], xyDiff+[p-q], xySum+[p+q])<br>    dfs([], [], [])<br>    <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h3 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubarraySumCircular</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 虽然数组变成了环形</span><br>    <span class="hljs-comment"># 但是我觉得还是可以用动态规划的思想来解决</span><br>    <span class="hljs-comment"># 对于数组中环状连续子数组的最大和问题，实际上可以分为两种情况考虑：</span><br>    <span class="hljs-comment"># 非环形子数组的最大和：这可以通过常规的动态规划（Kadane算法）来解决。遍历一次数组，找到非环形子数组可能的最大和。</span><br>    <span class="hljs-comment"># 跨越环形边界的子数组的最大和：这一部分稍微复杂一点，可以通过计算总和减去非环形子数组的最小和来得到。为此，需要再次应用动态规划来找到非环形子数组的最小和。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kadane</span>(<span class="hljs-params">nums</span>):<br>        dp = [nums[<span class="hljs-number">0</span>]] * <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br><br>    <span class="hljs-comment"># 首先求正常数组的最大值</span><br>    maxNormal = kadane(nums)<br>    <span class="hljs-keyword">if</span> maxNormal &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> maxNormal<br>    maxCircular = <span class="hljs-built_in">sum</span>(nums) + kadane([-x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxNormal, maxCircular)<br></code></pre></td></tr></table></figure><h3 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a href="https://leetcode.cn/problems/interleaving-string/">97. 交错字符串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 交错字符串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isInterleave</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, s3: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 既然是动态规划的题目</span><br>    <span class="hljs-comment"># 那就考虑创建dp数组</span><br>    l1, l2, l3 = <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">len</span>(s3)<br>    <span class="hljs-keyword">if</span> l1 + l2 != l3 : <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 创建一个l1+1xl2+1大小的数组</span><br>    <span class="hljs-comment"># dp[i][j]表示s3的前i+j个字符是否能被s1的前i个字符和s2的前j个字符交错组成。</span><br>    dp = [[<span class="hljs-literal">False</span>] * (l2 + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l1 + <span class="hljs-number">1</span>)]<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 如果当前字符s3[i+j-1]等于s1[i-1]且dp[i-1][j]是true，那么dp[i][j]也应该是true；</span><br>    <span class="hljs-comment"># 如果当前字符s3[i+j-1]等于s2[j-1]且dp[i][j-1]是true，那么dp[i][j]也应该是true。</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,l1+<span class="hljs-number">1</span>):<br>        dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> s1[i-<span class="hljs-number">1</span>] == s3[i-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2 +<span class="hljs-number">1</span>):<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> s2[j-<span class="hljs-number">1</span>] == s3[j-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l1+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> s1[i-<span class="hljs-number">1</span>] == s3[i+j-<span class="hljs-number">1</span>]:<br>                dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j]<br>            <span class="hljs-keyword">if</span> s2[j-<span class="hljs-number">1</span>] == s3[i+j-<span class="hljs-number">1</span>]:<br>                dp[i][j] |= dp[i][j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[l1][l2]<br></code></pre></td></tr></table></figure><h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最大正方形</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maximalSquare</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br><br>    <span class="hljs-comment"># 这个题目的状态转移方程大致如下</span><br>    <span class="hljs-comment"># 检查点dp[i][j] 需要检测左边、上边、左上边</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> matrix[<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    maxSide = <span class="hljs-number">0</span><br><br>    rows, cols = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    dp = [[<span class="hljs-number">0</span>] * cols <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows)]<br><br>    <span class="hljs-comment"># 遍历dp数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">0</span>:<br>                    dp[i][j] = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>],<br>                                   dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>                maxSide = <span class="hljs-built_in">max</span>(maxSide, dp[i][j])<br>    <span class="hljs-keyword">return</span> maxSide ** <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a><a href="https://leetcode.cn/problems/game-of-life/">289. 生命游戏</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生命游戏</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gameOfLife</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Do not return anything, modify board in-place instead.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 为了原地更新 board，但同时需要访问原始 board 状态，您可以使用额外的变量来表达更多状态。例如，可以规定：</span><br>    <span class="hljs-comment"># -1 表示这个细胞之前是活的，现在死了。 （这样才能用abs进行状态判断！！！）</span><br>    <span class="hljs-comment"># 3 表示这个细胞之前是死的，现在活了。</span><br><br>    rows, cols = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment"># 方向向量</span><br>    directions = [(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br>    <br>    <span class="hljs-comment"># 计算周围活着的邻居的数量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countLiveNeighbor</span>(<span class="hljs-params">r, c</span>):<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> directions:<br>            nr, nc = r + dr, c + dc<br>            <span class="hljs-comment"># 确保在合法区域内，并取绝对值判断原始状态</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nr &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nc &lt; cols <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(board[nr][nc]) == <span class="hljs-number">1</span>:<br>                count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br>    <br>    <span class="hljs-comment"># 第一遍遍历：基于原始状态更新为中间状态（2和3）</span><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            liveNeighbor = countLiveNeighbor(r, c)<br>            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (liveNeighbor &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> liveNeighbor &gt; <span class="hljs-number">3</span>):<br>                board[r][c] = -<span class="hljs-number">1</span>  <span class="hljs-comment"># 编码死亡状态</span><br>            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> liveNeighbor == <span class="hljs-number">3</span>:<br>                board[r][c] = <span class="hljs-number">3</span>  <span class="hljs-comment"># 编码新生状态</span><br>    <br>    <span class="hljs-comment"># 第二遍遍历：将中间状态解码为新状态</span><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            <span class="hljs-keyword">if</span> board[r][c] == -<span class="hljs-number">1</span>:<br>                board[r][c] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 解码死亡状态</span><br>            <span class="hljs-keyword">elif</span> board[r][c] == <span class="hljs-number">3</span>:<br>                board[r][c] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 解码新生状态</span><br></code></pre></td></tr></table></figure><h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉搜索树中第K小的元素</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目需要利用二叉搜索树的性质</span><br>    <span class="hljs-comment"># 即node.left.val &lt; node.val &lt; node.right.val</span><br>    <span class="hljs-comment"># 所以最小的绝对差</span><br>    <span class="hljs-comment"># 一定是相邻的节点</span><br>    <span class="hljs-comment"># 为了找到给定二叉搜索树中任意两节点的最小绝对差值，您可以对二叉搜索树进行中序遍历。由于二叉搜索树的中序遍历结果是一个递增的序列，那么任意两个相邻节点的差值将会是节点间的最小差值。</span><br>    inOrder = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inOrderTraverse</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inOrder) &gt;= k:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span><br>        inOrderTraverse(node.left)<br>        inOrder.append(node.val)<br>        inOrderTraverse(node.right)<br><br>    inOrderTraverse(root)<br><br>    <span class="hljs-keyword">return</span> inOrder[k-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉搜索树的最小绝对差</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMinimumDifference</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目需要利用二叉搜索树的性质</span><br>    <span class="hljs-comment"># 即node.left.val &lt; node.val &lt; node.right.val</span><br>    <span class="hljs-comment"># 所以最小的绝对差</span><br>    <span class="hljs-comment"># 一定是相邻的节点</span><br>    <span class="hljs-comment"># 为了找到给定二叉搜索树中任意两节点的最小绝对差值，您可以对二叉搜索树进行中序遍历。由于二叉搜索树的中序遍历结果是一个递增的序列，那么任意两个相邻节点的差值将会是节点间的最小差值。</span><br>    inOrder = []<br>    self.minDiff = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inOrderTraverse</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span><br>        inOrderTraverse(node.left)<br>        <span class="hljs-keyword">if</span> inOrder:<br>            self.minDiff = <span class="hljs-built_in">min</span>(self.minDiff, node.val - inOrder[-<span class="hljs-number">1</span>])<br>        inOrder.append(node.val)<br>        inOrderTraverse(node.right)<br><br>    inOrderTraverse(root)<br><br>    <span class="hljs-keyword">return</span> self.minDiff<br></code></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 验证二叉搜索树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 上述解法是狭隘的</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params">node, low=<span class="hljs-built_in">float</span>(<span class="hljs-params"><span class="hljs-string">&#x27;-inf&#x27;</span></span>), high=<span class="hljs-built_in">float</span>(<span class="hljs-params"><span class="hljs-string">&#x27;inf&#x27;</span></span>)</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (low &lt; node.val &lt; high):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 递归检查</span><br>        <span class="hljs-keyword">return</span> (validate(node.left, low, node.val) <span class="hljs-keyword">and</span><br>                validate(node.right, node.val, high))<br>    <span class="hljs-keyword">return</span> validate(root)<br></code></pre></td></tr></table></figure><h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单词接龙</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ladderLength</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br><br>    <span class="hljs-comment"># 首先建图</span><br>    bankSet = <span class="hljs-built_in">set</span>(wordList)<br>    <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> bankSet:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canTransform</span>(<span class="hljs-params">word1, word2</span>):<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c1, c2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(word1, word2):<br>            <span class="hljs-keyword">if</span> c1 != c2:<br>                count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count == <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 初始化队列</span><br>    queue = deque([(beginWord, <span class="hljs-number">1</span>)])<br><br>    <span class="hljs-keyword">while</span> queue:<br>        currentWord, stepCount = queue.popleft()<br>        <span class="hljs-keyword">if</span> currentWord == endWord:<br>            <span class="hljs-comment"># 第一个找到的一定是最小的</span><br>            <span class="hljs-keyword">return</span> stepCount<br>        <span class="hljs-comment"># 继续寻找</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(currentWord)):<br>            <span class="hljs-comment"># 按照26个英文字母进行遍历</span><br>            <span class="hljs-comment"># 对当前的word进行构造，如果能够构造出一个在bankset中的单词就加入队列</span><br>            <span class="hljs-comment"># 由于只能使用一次，所以删除bankset中的单词</span><br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:<br>                nextWord = currentWord[:i] + c + currentWord[i+<span class="hljs-number">1</span>:]<br>                <span class="hljs-keyword">if</span> canTransform(nextWord, currentWord) <span class="hljs-keyword">and</span> nextWord <span class="hljs-keyword">in</span> bankSet:<br>                    bankSet.remove(nextWord)<br>                    queue.append((nextWord, stepCount + <span class="hljs-number">1</span>))<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机链表的复制</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Optional[Node]&#x27;</span>:<br>    <span class="hljs-comment"># 这个题目的难点就在于随机节点的复制</span><br>    <span class="hljs-comment"># 目前想到的方法就是使用一个dict去存储映射关系</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 创建对应关系</span><br>    o2n = &#123;&#125;<br><br>    <span class="hljs-comment"># 第一次遍历,创建新的链表</span><br>    current = head<br>    <span class="hljs-keyword">while</span> current:<br>        copy = Node(current.val)<br>        o2n[current] = copy<br>        current = current.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-comment"># 再次遍历,建立random的对应关系</span><br>    current = head<br>    <span class="hljs-keyword">while</span> current:<br>        <span class="hljs-keyword">if</span> current.<span class="hljs-built_in">next</span>:<br>            o2n[current].<span class="hljs-built_in">next</span> = o2n[current.<span class="hljs-built_in">next</span>]<br>        <span class="hljs-keyword">if</span> current.random:<br>            o2n[current].random = o2n[current.random]<br>        current = current.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">return</span> o2n[head]<br></code></pre></td></tr></table></figure><h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># K 个一组翻转链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 思路就是先分解成子问题,再按照标准的反转方法进行反转</span><br>    dummy = ListNode(<span class="hljs-number">0</span>)<br>    dummy.<span class="hljs-built_in">next</span> = head<br>    prev, end = dummy, dummy<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">start</span>):<br>        prev = <span class="hljs-literal">None</span><br>        curr = start<br>        <span class="hljs-keyword">while</span> curr:<br>            nextTemp = curr.<span class="hljs-built_in">next</span><br>            curr.<span class="hljs-built_in">next</span> = prev<br>            <span class="hljs-comment"># 移动到下一个位置</span><br>            prev = curr<br>            curr = nextTemp<br>        <span class="hljs-keyword">return</span> prev<br><br>    <span class="hljs-keyword">while</span> end.<span class="hljs-built_in">next</span>:<br>        <span class="hljs-comment"># 找到每组的k个节点</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            end = end.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> end:<br>                <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 记录next</span><br>        start = prev.<span class="hljs-built_in">next</span><br>        <span class="hljs-built_in">next</span> = end.<span class="hljs-built_in">next</span><br><br>        end.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 反转当前k个节点</span><br>        prev.<span class="hljs-built_in">next</span> = reverse(start)<br>        start.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 重新确定prev的位置</span><br>        prev = start<br>        end = prev<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">findOrder</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-comment"># 这个题目依然是拓扑排序</span><br>    <span class="hljs-comment"># 先把1的代码抄过来</span><br>    graph = defaultdict(<span class="hljs-built_in">list</span>)<br>    indegrees = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br><br>    <span class="hljs-comment"># 构建图</span><br>    <span class="hljs-keyword">for</span> cur,pre <span class="hljs-keyword">in</span> prerequisites:<br>        graph[pre].append(cur)<br>        indegrees[cur] += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 进行拓扑排序</span><br>    queue = deque([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses) <span class="hljs-keyword">if</span> indegrees[i] == <span class="hljs-number">0</span>] )<br><br>    <span class="hljs-comment"># 结果数组</span><br>    res = []<br>    finishedCourse = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span> queue:<br>        course = queue.popleft()<br>        <span class="hljs-comment"># 课程数+1</span><br>        finishedCourse += <span class="hljs-number">1</span><br>        res.append(course)<br>        <span class="hljs-comment"># 入度-1</span><br>        <span class="hljs-keyword">for</span> nextCourse <span class="hljs-keyword">in</span> graph[course]:<br>            indegrees[nextCourse] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> indegrees[nextCourse] == <span class="hljs-number">0</span>:<br>                queue.append(nextCourse)<br>    <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> finishedCourse == numCourses <span class="hljs-keyword">else</span> []<br></code></pre></td></tr></table></figure><h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">canFinish</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 这就是一个图的拓扑排序问题</span><br>    graph = defaultdict(<span class="hljs-built_in">list</span>)<br>    indegrees = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br><br>    <span class="hljs-comment"># 构建图</span><br>    <span class="hljs-keyword">for</span> cur,pre <span class="hljs-keyword">in</span> prerequisites:<br>        graph[pre].append(cur)<br>        indegrees[cur] += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 进行拓扑排序</span><br>    queue = deque([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses) <span class="hljs-keyword">if</span> indegrees[i] == <span class="hljs-number">0</span>] )<br><br>    finishedCourse = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span> queue:<br>        course = queue.popleft()<br>        <span class="hljs-comment"># 课程数+1</span><br>        finishedCourse += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 入度-1</span><br>        <span class="hljs-keyword">for</span> nextCourse <span class="hljs-keyword">in</span> graph[course]:<br>            indegrees[nextCourse] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> indegrees[nextCourse] == <span class="hljs-number">0</span>:<br>                queue.append(nextCourse)<br>    <span class="hljs-keyword">return</span> finishedCourse == numCourses<br>    <br></code></pre></td></tr></table></figure><h3 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a><a href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最小基因变化</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minMutation</span>(<span class="hljs-params">self, startGene: <span class="hljs-built_in">str</span>, endGene: <span class="hljs-built_in">str</span>, bank: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目的想法就是先建图</span><br>    <span class="hljs-comment"># 基因库中的基因是可以相互转换的，并且start可以转换到基因库中的基因</span><br>    <span class="hljs-comment"># 因此建图后可以通过bfs，找到最小的转变次数</span><br>    <span class="hljs-comment"># 一次基因变化就意味着这个基因序列中的一个字符发生了变化</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidMutation</span>(<span class="hljs-params">gene1, gene2</span>):<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gene1)):<br>            <span class="hljs-keyword">if</span> gene1[i] != gene2[i]:<br>                count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> count == <span class="hljs-number">1</span><br><br>    bankSet = <span class="hljs-built_in">set</span>(bank)<br>    <span class="hljs-keyword">if</span> endGene <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> bankSet:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>    queue = deque([(startGene, <span class="hljs-number">0</span>)])<br>    <span class="hljs-keyword">while</span> queue:<br>        currGene, mutations = queue.popleft()<br>        <span class="hljs-keyword">if</span> currGene == endGene:<br>            <span class="hljs-keyword">return</span> mutations<br>        <span class="hljs-keyword">for</span> gene <span class="hljs-keyword">in</span> bankSet.copy():<br>            <span class="hljs-keyword">if</span> isValidMutation(currGene, gene):<br>                bankSet.remove(gene)<br>                queue.append((gene, mutations + <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="909-蛇梯棋"><a href="#909-蛇梯棋" class="headerlink" title="909. 蛇梯棋"></a><a href="https://leetcode.cn/problems/snakes-and-ladders/">909. 蛇梯棋</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 蛇梯棋</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">snakesAndLadders</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 读题读了半天</span><br>    <span class="hljs-comment"># 感觉可以用一个模拟解决</span><br>    <span class="hljs-comment"># 但这个是放在bfs里面的</span><br>    <span class="hljs-comment"># 先抄一下</span><br>    <span class="hljs-comment"># 因此，BFS策略天然适合用于解决在无权图（即所有边的权重都相同的图）中找到最短路径的问题</span><br>    n = <span class="hljs-built_in">len</span>(board)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">s</span>):<br>        quot, rem = <span class="hljs-built_in">divmod</span>(s - <span class="hljs-number">1</span>, n)<br>        row = n - <span class="hljs-number">1</span> - quot<br>        col = rem <span class="hljs-keyword">if</span> row % <span class="hljs-number">2</span> != (n % <span class="hljs-number">2</span>) <span class="hljs-keyword">else</span> n - <span class="hljs-number">1</span> - rem<br>        <span class="hljs-keyword">return</span> row, col<br><br>    queue = deque([<span class="hljs-number">1</span>])<br>    visited = <span class="hljs-built_in">set</span>()<br>    step = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span> queue:<br>        size = <span class="hljs-built_in">len</span>(queue)<br>        s = queue.popleft()<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">if</span> s == n * n:<br>                <span class="hljs-keyword">return</span> step<br>            <span class="hljs-comment"># 模拟骰子🎲</span><br>            <span class="hljs-keyword">for</span> s2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s + <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(s+<span class="hljs-number">6</span>, n*n) + <span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># 因为是平方，所以需要转换一下坐标</span><br>                r, c = get(s2)<br>                <span class="hljs-keyword">if</span> board[r][c] != -<span class="hljs-number">1</span>:<br>                    s2 = board[r][c]<br>                <span class="hljs-keyword">if</span> s2 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                    visited.add(s2)<br>                    queue.append(s2)<br>        step += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 如果还没有到达终点说明无法到达</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calcEquation</span>(<span class="hljs-params">self, equations: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], values: <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>], queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>    <span class="hljs-comment"># 替换成有向图的遍历问题</span><br>    <span class="hljs-comment"># 除法的算式作为节点和边</span><br>    <span class="hljs-comment"># 建立图</span><br>    self.graph = defaultdict(<span class="hljs-built_in">dict</span>)<br>    <span class="hljs-comment"># 将算式和结果加入（倒数也要加入）</span><br>    <span class="hljs-keyword">for</span> (dividend, divisor), value <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(equations, values):<br>        self.graph[dividend][divisor] = value<br>        self.graph[divisor][dividend] = <span class="hljs-number">1.0</span> / value<br><br>    <span class="hljs-comment"># 进行dfs遍历</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">start, end, visited</span>):<br>        <span class="hljs-keyword">if</span> start <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.graph:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0</span><br>        <span class="hljs-keyword">if</span> start == end:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span><br>        visited.add(start)<br><br>        <span class="hljs-keyword">for</span> neighbor, value <span class="hljs-keyword">in</span> self.graph[start].items():<br>            <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">in</span> visited:<br>                <span class="hljs-keyword">continue</span><br><br>            visited.add(neighbor)<br><br>            temp = dfs(neighbor, end, visited)<br>            <span class="hljs-keyword">if</span> temp != - <span class="hljs-number">1.0</span>:<br>                <span class="hljs-keyword">return</span> value * temp<br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1.0</span><br><br>    <span class="hljs-keyword">return</span> [dfs(Cj, Dj, <span class="hljs-built_in">set</span>()) <span class="hljs-keyword">for</span> Cj, Dj <span class="hljs-keyword">in</span> queries]<br></code></pre></td></tr></table></figure><h3 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode.cn/problems/clone-graph/">133. 克隆图</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cloneGraph</span>(<span class="hljs-params">self, node: <span class="hljs-type">Optional</span>[<span class="hljs-string">&#x27;Node&#x27;</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[<span class="hljs-string">&#x27;Node&#x27;</span>]:<br>    <span class="hljs-comment"># 需要深拷贝</span><br>    <span class="hljs-comment"># 使用dfs进行遍历</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    visited = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> visited:<br>            <span class="hljs-keyword">return</span> visited[node]<br><br>        clonedNode = Node(node.val)<br>        visited[node] = clonedNode<br><br>        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> node.neighbors:<br>            clonedNodeNeighbor = dfs(neighbor)<br>            clonedNode.neighbors.append(clonedNodeNeighbor)<br><br>        <span class="hljs-keyword">return</span> clonedNode<br>    <span class="hljs-keyword">return</span> dfs(node)<br></code></pre></td></tr></table></figure><h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 被围绕的区域</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-comment"># 感觉和岛屿数量差不多 只是需要稍微修改一下代码</span><br>    <span class="hljs-comment"># 但是实际上的解决思路应该是</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> board[<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= <span class="hljs-built_in">len</span>(board) <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> board[i][j] != <span class="hljs-string">&#x27;O&#x27;</span>:<br>            <span class="hljs-keyword">return</span><br>        board[i][j] = <span class="hljs-string">&#x27;A&#x27;</span><br>        dfs(i, j+<span class="hljs-number">1</span>)<br>        dfs(i+<span class="hljs-number">1</span>, j)<br>        dfs(i-<span class="hljs-number">1</span>, j)<br>        dfs(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 对边界的O进行处理</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board)):<br>        dfs(i, <span class="hljs-number">0</span>)<br>        dfs(i, <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])):<br>        dfs(<span class="hljs-number">0</span>, j)<br>        dfs(<span class="hljs-built_in">len</span>(board)-<span class="hljs-number">1</span>, j)<br>    <span class="hljs-comment"># 现在情况下，与边界O相连的区域已经全是A了，只需要将剩下的O替换成X即可，A替换成O</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span><br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>:<br>                board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span><br><br></code></pre></td></tr></table></figure><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 岛屿数量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>        <span class="hljs-comment"># 如果触碰到岛屿的边界或者是地图的边界，直接返回，不会进行下一步的操作了</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= <span class="hljs-built_in">len</span>(grid) <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 核心思路就是每次找到一个1 就把它和他周围的1标记成0 记录为一块岛屿</span><br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>        <span class="hljs-comment"># 探查周围的岛屿数量</span><br>        dfs(i+<span class="hljs-number">1</span>, j)<br>        dfs(i-<span class="hljs-number">1</span>, j)<br>        dfs(i, j+<span class="hljs-number">1</span>)<br>        dfs(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                dfs(i, j)<br>                count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">zigzagLevelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 应该是需要加个flag记录是否翻转</span><br>    res = []<br>    queue = deque()<br>    isFlip = <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 首先加入队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> res<br><br>    queue.append(root)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 首先需要记录当前层的长度</span><br>        levelLen = <span class="hljs-built_in">len</span>(queue)<br>        levelRes = []<br>        <span class="hljs-comment"># 层序遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(levelLen):<br>            node = queue.popleft()<br>            <span class="hljs-keyword">if</span> isFlip:<br>                <span class="hljs-comment"># 应该是改变元素插入的顺序，而不是遍历方式</span><br>                levelRes.insert(<span class="hljs-number">0</span>, node.val)<br>            <span class="hljs-keyword">else</span>:<br>                levelRes.append(node.val)<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>        isFlip = <span class="hljs-keyword">not</span> isFlip<br>        res.append(levelRes)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树的层序遍历</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    res = []<br>    queue = deque()<br>    <span class="hljs-comment"># 首先加入队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> res<br><br>    queue.append(root)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 首先需要记录当前层的长度</span><br>        levelLen = <span class="hljs-built_in">len</span>(queue)<br>        levelRes = []<br>        <span class="hljs-comment"># 层序遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(levelLen):<br>            node = queue.popleft()<br>            levelRes.append(node.val)<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>        <span class="hljs-comment"># 计算平均值</span><br>        res.append(levelRes)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树的层平均值</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfLevels</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>    res = []<br>    queue = deque()<br>    <span class="hljs-comment"># 首先加入队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> res<br><br>    queue.append(root)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 首先需要记录当前层的长度</span><br>        levelLen = <span class="hljs-built_in">len</span>(queue)<br>        levelSum = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 层序遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(levelLen):<br>            node = queue.popleft()<br>            <span class="hljs-comment"># 如果是最后一个节点</span><br>            levelSum += node.val<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>        <span class="hljs-comment"># 计算平均值</span><br>        res.append(levelSum/levelLen)<br>    <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 二叉树的右视图</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rightSideView</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-comment"># 右视图</span><br>    <span class="hljs-comment"># 多分析几个情况</span><br>    <span class="hljs-comment"># 应该可以用递归解决</span><br>    <span class="hljs-comment"># 还和层高有关系，那么应该用层序遍历，将每一层的最后一个节点加入res</span><br>    res = []<br>    queue = deque()<br>    <span class="hljs-comment"># 首先加入队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> res<br><br>    queue.append(root)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 首先需要记录当前层的长度</span><br>        levelLen = <span class="hljs-built_in">len</span>(queue)<br><br>        <span class="hljs-comment"># 层序遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(levelLen):<br>            node = queue.popleft()<br>            <span class="hljs-comment"># 如果是最后一个节点</span><br>            <span class="hljs-keyword">if</span> i == levelLen - <span class="hljs-number">1</span>:<br>                res.append(node.val)<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树中的最大路径和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目感觉有点像动态规划的思路</span><br>    self.maxSum = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        leftGain = <span class="hljs-built_in">max</span>(dfs(node.left), <span class="hljs-number">0</span>)<br>        rightGain = <span class="hljs-built_in">max</span>(dfs(node.right), <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 当前节点所在的路径最大值</span><br>        pathSum = node.val + leftGain + rightGain<br><br>        <span class="hljs-comment"># 判断当前和全局最大值的大小关系</span><br>        self.maxSum = <span class="hljs-built_in">max</span>(self.maxSum, pathSum)<br>        <span class="hljs-comment"># 为什么只返回其中一边的gain呢？ 避免重复</span><br><br>        <span class="hljs-comment"># 一个节点要么自身成为边的根节点，要么成为贡献者</span><br>        <span class="hljs-comment"># 所以他的返回值应该是单边的gain</span><br>        <span class="hljs-keyword">return</span> node.val + <span class="hljs-built_in">max</span>(leftGain, rightGain)<br><br>    dfs(root)<br>    <span class="hljs-keyword">return</span> self.maxSum<br></code></pre></td></tr></table></figure><h3 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a><a href="https://leetcode.cn/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉搜索树迭代器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>):<br>        <span class="hljs-comment"># 初始化一个空栈</span><br>        self.stack = []<br>        <span class="hljs-comment"># 将左子树节点加入</span><br>        self.leftmostInorder(root)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">leftmostInorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-keyword">while</span> root:<br>            self.stack.append(root)<br>            root = root.left<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        topmostNode = self.stack.pop()<br><br>        <span class="hljs-keyword">if</span> topmostNode.right:<br>            self.leftmostInorder(topmostNode.right)<br><br>        <span class="hljs-keyword">return</span> topmostNode.val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stack) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><ul><li>优化版<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 完全二叉树的节点个数</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">countNodes</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countHeight</span>(<span class="hljs-params">node</span>):<br>        height = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> node:<br>            node = node.left<br>            height += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> height<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 分别求左右子树的高度</span><br>    leftHeight = countHeight(root.left)<br>    rightHeight = countHeight(root.right)<br><br>    <span class="hljs-comment"># 判断左右子树的高度关系</span><br>    <span class="hljs-keyword">if</span> leftHeight == rightHeight:<br>        <span class="hljs-comment"># 如果左右子树高度相等</span><br>        <span class="hljs-comment"># 说明现在左子树是满二叉树，需要递归判断右子树的情况</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; leftHeight) - <span class="hljs-number">1</span> + self.countNodes(root.right) + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 说明现在右子树是满的，需要递归判断左子树</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; rightHeight) - <span class="hljs-number">1</span> + self.countNodes(root.left) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>普通版<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通版</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">countNodes</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树的最近公共祖先</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:<br>    <span class="hljs-comment"># 感觉可以转换一下思路</span><br>    <span class="hljs-comment"># 与其说是找最近公共祖先,不如说在当前root下能否找到p和q</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> root == p <span class="hljs-keyword">or</span> root == q:<br>        <span class="hljs-keyword">return</span> root<br><br>    <span class="hljs-comment"># 在左子树中找pq</span><br>    left = self.lowestCommonAncestor(root.left, p, q)<br>    right = self.lowestCommonAncestor(root.right, p, q)<br><br>    <span class="hljs-comment"># 如果两个节点都不为空，可以直接返回了</span><br>    <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> right:<br>        <span class="hljs-keyword">return</span> root<br>    <span class="hljs-comment"># 否则返回不为空的那半颗树的根节点</span><br>    <span class="hljs-keyword">return</span> left <span class="hljs-keyword">if</span> left <span class="hljs-keyword">else</span> right<br></code></pre></td></tr></table></figure><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 路径总和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, <span class="hljs-built_in">sum</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-built_in">sum</span> += node.val<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span> == targetSum<br><br>        <span class="hljs-comment"># 递归判断左右子树</span><br>        <span class="hljs-keyword">return</span> dfs(node.left, <span class="hljs-built_in">sum</span>) <span class="hljs-keyword">or</span> dfs(node.right, <span class="hljs-built_in">sum</span>)<br>    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求根节点到叶节点数字之和</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sumNumbers</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 递归（循环）思路</span><br>    <span class="hljs-comment"># root * 10 + val</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, currentNumber</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        currentNumber = currentNumber * <span class="hljs-number">10</span> + node.val<br><br>        <span class="hljs-comment"># 如果是叶子节点，就直接返回</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>            <span class="hljs-keyword">return</span> currentNumber<br><br>        <span class="hljs-comment"># 递归计算左右zishu</span><br>        leftSum = dfs(node.left, currentNumber)<br>        rightSum = dfs(node.right, currentNumber)<br><br>        <span class="hljs-keyword">return</span> leftSum + rightSum<br><br>    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树展开为链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Do not return anything, modify root in-place instead.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <br>    <br>    self.flatten(root.left)<br>    self.flatten(root.right)<br><br>    <span class="hljs-comment"># 暂时保存右子树</span><br>    tempRight = root.right<br><br>    <span class="hljs-comment"># 将flatten以后的进行操作</span><br>    root.right = root.left<br>    root.left = <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 一路遍历到叶子节点</span><br>    <span class="hljs-keyword">while</span> root.right:<br>        root = root.right<br>    <span class="hljs-comment"># 将原来的右子树拼接在最后</span><br>    root.right = tempRight<br></code></pre></td></tr></table></figure><h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 填充每个节点的下一个右侧节点指针 II</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>, left: <span class="hljs-string">&#x27;Node&#x27;</span> = <span class="hljs-literal">None</span>, right: <span class="hljs-string">&#x27;Node&#x27;</span> = <span class="hljs-literal">None</span>, <span class="hljs-built_in">next</span>: <span class="hljs-string">&#x27;Node&#x27;</span> = <span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>    <span class="hljs-comment"># 看到题目的要求 想到了二叉树的层序遍历</span><br>    <span class="hljs-comment"># 层序遍历需要使用队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 初始化队列，将根节点加入</span><br>    queue = deque([root])<br><br>    <span class="hljs-keyword">while</span> queue:<br>        size = <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-comment"># 遍历当前层的节点</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            node = queue.popleft()<br>            <span class="hljs-comment"># 如果不是最右边的节点，则将next指针指向右边的</span><br>            <span class="hljs-keyword">if</span> i &lt; size - <span class="hljs-number">1</span>:<br>                node.<span class="hljs-built_in">next</span> = queue[<span class="hljs-number">0</span>]<br><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>    <span class="hljs-keyword">return</span> root<br>    <br></code></pre></td></tr></table></figure><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><ul><li>这两个题都利用了一个性质，左右子树的元素个数是一致的<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从前序与中序遍历序列构造二叉树</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>    <span class="hljs-comment"># 给定的输入如下：</span><br>    <span class="hljs-comment"># 前序遍历：[3, 9, 20, 15, 7]</span><br>    <span class="hljs-comment"># 中序遍历：[9, 3, 15, 20, 7]</span><br>    <span class="hljs-comment"># 首先，根据前序遍历，我们知道根节点是3。</span><br>    <span class="hljs-comment"># 对于中序遍历[9, 3, 15, 20, 7]：</span><br>    <span class="hljs-comment"># 根节点3之前的所有节点[9]构成左子树。</span><br>    <span class="hljs-comment"># 根节点3之后的所有节点[15, 20, 7]构成右子树。</span><br>    <span class="hljs-comment"># 接下来，我们就有了两个子问题：</span><br>    <span class="hljs-comment"># 左子树的前序遍历是[9]，中序遍历是[9]。</span><br>    <span class="hljs-comment"># 右子树的前序遍历是[20, 15, 7]，中序遍历是[15, 20, 7]。</span><br>    <span class="hljs-comment"># 确定根节点：在前序遍历中找到树的根节点（序列的第一个元素）。</span><br>    <span class="hljs-comment"># 划分树的左右子树：在中序遍历序列中找到根节点，这样就可以确定左子树和右子树的节点。</span><br>    <span class="hljs-comment"># 递归构造子树：对于根节点的左侧和右侧序列，重复以上过程，构造左子树和右子树。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> inorder:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 第一个一定是根节点</span><br>    root = TreeNode(preorder[<span class="hljs-number">0</span>])<br>    mid = inorder.index(preorder[<span class="hljs-number">0</span>])<br><br>    root.left = self.buildTree(preorder[<span class="hljs-number">1</span>:mid+<span class="hljs-number">1</span>], inorder[:mid])<br>    root.right = self.buildTree(preorder[mid+<span class="hljs-number">1</span>:], inorder[mid+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure></li></ul><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从中序与后序遍历序列构造二叉树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], postorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>    <span class="hljs-comment"># 需要注意的是，后序遍历的最后一个节点一定是根节点，所以这个题目就很简单了</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> postorder:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 最后一个一定是根节点</span><br>    root = TreeNode(postorder[-<span class="hljs-number">1</span>])<br>    mid = inorder.index(postorder[-<span class="hljs-number">1</span>])<br><br>    root.left = self.buildTree(inorder[:mid+<span class="hljs-number">1</span>], postorder[:mid])<br>    root.right = self.buildTree(inorder[mid+<span class="hljs-number">1</span>:], postorder[mid:-<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对称二叉树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 判断对称这个简单</span><br>    <span class="hljs-comment"># 只需要递归的判断左右子树是否对称即可</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">left, right</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (left <span class="hljs-keyword">or</span> right):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (left <span class="hljs-keyword">and</span> right):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> left.val != right.val:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> dfs(left.left, right.right) <span class="hljs-keyword">and</span> dfs(left.right, right.left)<br><br>    <span class="hljs-keyword">return</span> dfs(root.left, root.right)<br></code></pre></td></tr></table></figure><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 翻转二叉树</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>    <span class="hljs-comment"># 需要翻转二叉树的左右子树</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 翻转左子树</span><br>    left = self.invertTree(root.left)<br><br>    <span class="hljs-comment"># 翻转右子树</span><br>    right = self.invertTree(root.right)<br><br>    <span class="hljs-comment"># 交换翻转后的节点</span><br>    root.left, root.right = right, left<br><br>    <span class="hljs-keyword">return</span> roots<br></code></pre></td></tr></table></figure><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 相同的树</span><br><span class="hljs-comment"># 关键点还是在于遍历</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isSameTree</span>(<span class="hljs-params">self, p: <span class="hljs-type">Optional</span>[TreeNode], q: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 还得是题解</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> q:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> q:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> p.val != q.val:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 递归检查左右子树</span><br>    <span class="hljs-keyword">return</span> self.isSameTree(p.left, q.left) <span class="hljs-keyword">and</span> self.isSameTree(p.right, q.right)<br><br></code></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树的最大深度</span><br><span class="hljs-comment"># 很简单的一道二叉树的遍历题，帮我回顾二叉树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 创建一个变量记录最大深度</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node: <span class="hljs-type">Optional</span>[TreeNode]</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        leftDepth = dfs(node.left)<br>        rightDepth = dfs(node.right)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftDepth, rightDepth) + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> dfs(root)<br></code></pre></td></tr></table></figure><h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 创建两个附加头节点</span><br>    head1 = ListNode()<br>    head2 = ListNode()<br>    cur1 = head1<br>    cur2 = head2<br>    <span class="hljs-keyword">while</span> head:<br>        <span class="hljs-keyword">if</span> head.val &lt; x:<br>            cur1.<span class="hljs-built_in">next</span> = ListNode(head.val)<br>            cur1 = cur1.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">else</span>:<br>            cur2.<span class="hljs-built_in">next</span> = ListNode(head.val)<br>            cur2 = cur2.<span class="hljs-built_in">next</span><br>        head = head.<span class="hljs-built_in">next</span><br>    <span class="hljs-comment"># 拼接两个链表</span><br>    <span class="hljs-comment"># 注意拼接的位置</span><br>    cur1.<span class="hljs-built_in">next</span> = head2.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> head1.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateRight</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 这个题实际上不是翻转链表 而是旋转链表</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">or</span> k == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> head<br><br>    cur = head<br>    length = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> cur.<span class="hljs-built_in">next</span>:<br>        cur = cur.<span class="hljs-built_in">next</span><br>        length += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 形成环</span><br>    cur.<span class="hljs-built_in">next</span> = head<br><br>    <span class="hljs-comment"># 找到旋转后的链表的尾巴，从尾巴处切开就是新的链表</span><br>    tail = head<br>    steps = length - k % length<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(steps - <span class="hljs-number">1</span>):<br>        tail = tail.<span class="hljs-built_in">next</span><br><br>    newHead = tail.<span class="hljs-built_in">next</span><br>    tail.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> newHead<br></code></pre></td></tr></table></figure><h3 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode.cn/problems/simplify-path/">71. 简化路径</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简化路径</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">simplifyPath</span>(<span class="hljs-params">self, path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 创建一个栈</span><br>    stack = []<br>    <span class="hljs-comment"># 首先去掉多余的/</span><br>    <span class="hljs-comment"># 使用正则表达式进行匹配</span><br>    path = re.sub(<span class="hljs-string">r&#x27;/+&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, path)<br>    <span class="hljs-comment"># 将path转换成数组</span><br>    paths = path.split(<span class="hljs-string">&#x27;/&#x27;</span>)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> paths:<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> item == <span class="hljs-string">&#x27;&#x27;</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;..&#x27;</span>:<br>            <span class="hljs-keyword">if</span> stack:<br>                stack.pop()<br>            <span class="hljs-keyword">continue</span><br>        stack.append(item)<br>    <span class="hljs-comment"># 不需要对字符串进行翻转</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-string">&#x27;/&#x27;</span>.join(stack)<br></code></pre></td></tr></table></figure><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 用一个变量维护最小值的方式不太可取，因为pop时总是需要找到下一个最小值，是否能够满足在常数时间复杂度内完成这个操作</span><br>        <span class="hljs-comment"># 但是可以创一个辅助的栈来帮助我们完成</span><br>        self.stack = []<br>        self.minStack = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 常规push</span><br>        self.stack.append(val)<br>        <span class="hljs-comment"># 最小栈的维护</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.minStack <span class="hljs-keyword">or</span> val &lt;= self.minStack[-<span class="hljs-number">1</span>]:<br>            self.minStack.append(val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 为什么要再次加入最小元素</span><br>            <span class="hljs-comment"># 因为始终保持了同步</span><br>            self.minStack.append(self.minStack[-<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.stack.pop()<br>        self.minStack.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> self.minStack[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用最少数量的箭引爆气球</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findMinArrowShots</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 感觉这个题也是合并区间</span><br>    <span class="hljs-comment"># 找到最后不能合并的区间的个数</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> points:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    nums = <span class="hljs-built_in">len</span>(points)<br>    <span class="hljs-comment"># 注意:由于至少需要一只箭,所以初始化为1</span><br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 首先points按照第一个元素的顺序排序</span><br>    points.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>    <span class="hljs-comment"># 然后遍历point</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 可以只记录一个end即可</span><br>    end = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(points)):<br>        <span class="hljs-keyword">if</span> points[i][<span class="hljs-number">0</span>] &gt; end:<br>            res += <span class="hljs-number">1</span><br>            end = points[i][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure><h3 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 插入区间</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], newInterval: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    res = []<br>    i = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(intervals) <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>]:<br>        res.append(intervals[i])<br>        i += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(intervals) <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>]:<br>        newInterval = [<span class="hljs-built_in">min</span>(newInterval[<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">0</span>]),<br>                       <span class="hljs-built_in">max</span>(newInterval[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>])]<br>        i += <span class="hljs-number">1</span><br>    res.append(newInterval)<br><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(intervals):<br>        res.append(intervals[i])<br>        i += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="🌟76-最小覆盖子串"><a href="#🌟76-最小覆盖子串" class="headerlink" title="🌟76. 最小覆盖子串"></a>🌟<a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最小覆盖子串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minWindow</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> t:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment"># 创建字典记录字母的出现次数</span><br>    tDict = Counter(t)<br><br>    <span class="hljs-comment"># 创建滑动窗口的边界</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># formed 用于记录当前窗口中满足 t_dict 条件的字符数</span><br>    formed = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 需要满足的字符数</span><br>    required = <span class="hljs-built_in">len</span>(tDict)<br><br>    windowDict = &#123;&#125;<br><br>    <span class="hljs-comment"># ans 用于记录最小覆盖子串的位置信息和长度</span><br>    <span class="hljs-comment"># (子串长度, 左边界索引, 右边界索引)</span><br>    ans = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>), <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">while</span> right &lt; <span class="hljs-built_in">len</span>(s):<br><br>        character = s[right]<br>        windowDict[character] = windowDict.get(character, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> character <span class="hljs-keyword">in</span> tDict <span class="hljs-keyword">and</span> windowDict[character] == tDict[character]:<br>            formed += <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 缩小滑动窗口</span><br>        <span class="hljs-keyword">while</span> left &lt;= right <span class="hljs-keyword">and</span> formed == required:<br>            character = s[left]<br>            <span class="hljs-comment"># 判断是否更新答案</span><br>            <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> &lt; ans[<span class="hljs-number">0</span>]:<br>                ans = (right - left + <span class="hljs-number">1</span>, left, right)<br>            windowDict[character] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> character <span class="hljs-keyword">in</span> tDict <span class="hljs-keyword">and</span> windowDict[character] &lt; tDict[character]:<br>                formed -= <span class="hljs-number">1</span><br>            left += <span class="hljs-number">1</span><br>        right += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">if</span> ans[<span class="hljs-number">0</span>] == <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">else</span> s[ans[<span class="hljs-number">1</span>]:ans[<span class="hljs-number">2</span>]+<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="🌟30-串联所有单词的子串"><a href="#🌟30-串联所有单词的子串" class="headerlink" title="🌟30. 串联所有单词的子串"></a>🌟<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 串联所有单词的子串</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> words <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> s:<br>        <span class="hljs-keyword">return</span> []<br>    <span class="hljs-comment"># 每个单词的长度都是相同的</span><br>    wordLen = <span class="hljs-built_in">len</span>(words[<span class="hljs-number">0</span>])<br>    wordCount = <span class="hljs-built_in">len</span>(words)<br>    totalLen = wordLen * wordCount<br>    <span class="hljs-comment"># 使用哈希表存储words中单词的出现次数</span><br>    wordFreq = Counter(words)<br>    <span class="hljs-comment"># 结果列表</span><br>    indices = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(wordLen):<br>        left = i<br>        right = i<br>        currentFreq = Counter()<br><br>        <span class="hljs-keyword">while</span> right + wordLen &lt;= <span class="hljs-built_in">len</span>(s):<br>            word = s[right:right + wordLen]<br>            right += wordLen<br>            <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> wordFreq:<br>                currentFreq[word] += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 如果当前单词频率超过所需频率，则移动左指针直到频率正常</span><br>                <span class="hljs-keyword">while</span> currentFreq[word] &gt; wordFreq[word]:<br>                    leftWord = s[left:left + wordLen]<br>                    currentFreq[leftWord] -= <span class="hljs-number">1</span><br>                    left += wordLen<br>                <span class="hljs-keyword">if</span> right - left == totalLen:<br>                    indices.append(left)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 当前单词不在 word_freq 中，重置 left 和 current_freq</span><br>                currentFreq.clear()<br>                left = right<br>    <span class="hljs-keyword">return</span> indices<br></code></pre></td></tr></table></figure><h3 id="🌟373-查找和最小的-K-对数字"><a href="#🌟373-查找和最小的-K-对数字" class="headerlink" title="🌟373. 查找和最小的 K 对数字"></a>🌟<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a></h3><ul><li>使用堆</li><li>掌握的不是很牢，需要巩固<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查找和最小的 K 对数字</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kSmallestPairs</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 不会做，抄一下</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums1 <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> nums2:<br>        <span class="hljs-keyword">return</span> []<br><br>    minHeap = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(k, <span class="hljs-built_in">len</span>(nums1))):<br>        heapq.heappush(minHeap, (nums1[i]+nums2[<span class="hljs-number">0</span>], i, <span class="hljs-number">0</span>))<br><br>    result = []<br><br>    <span class="hljs-keyword">while</span> k &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> minHeap:<br>        sumVal, i, j = heapq.heappop(minHeap)<br>        result.append([nums1[i], nums2[j]])<br><br>        <span class="hljs-keyword">if</span> j + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(nums2):<br>            heapq.heappush(minHeap, (nums1[i]+nums2[j + <span class="hljs-number">1</span>], i, j+<span class="hljs-number">1</span>))<br>        k -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li></ul><h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数组中的第K个最大元素</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 获取第k大的元素，一个符合直觉的方法就是排序</span><br>    <span class="hljs-comment"># 但是这个是在 堆 这个系列里面的</span><br>    <span class="hljs-comment"># 说明如果使用排序</span><br>    <span class="hljs-comment"># 肯定会超过时间</span><br>    <span class="hljs-comment"># 而且存在问题,因为可能有重复元素(这个题似乎没有这个限制)</span><br>    nums.sort(reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> nums[k-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 定义一个最小堆</span><br>    heap = []<br>    <span class="hljs-comment"># 维护一个包含k个元素的最小堆</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>        heapq.heappush(heap, num)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heap) &gt; k:<br>            heapq.heappop(heap)<br>    <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最长递增子序列</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 创建dp数组</span><br>    <span class="hljs-comment"># 由于输出的是最长递增子序列的长度，所以dp数组表示的含义是到第i个字符时的序列长度</span><br>    dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-comment"># 这里存在一个问题，就是没有比较i之前的所有元素</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 最后返回的应该是dp子数组的最大值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3><ul><li>普通dp<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打家劫舍</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 首先创建dp数组</span><br>    dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 在计算 dp[1] 的值时，您应该考虑抢第一家和不抢第一家、</span><br>    <span class="hljs-comment"># 只抢第二家之间的选择，即 dp[1] 应该是 nums[0] 和 nums[1] 中的较大者，</span><br>    <span class="hljs-comment"># 而不是直接赋值 nums[1]</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li><li>状态压缩dp<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用状态压缩进行优化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 创建两个状态</span><br>    prev, cur = nums[<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-comment"># 先保存好cur</span><br>        temp = cur<br>        cur = <span class="hljs-built_in">max</span>(cur, nums[i] + prev)<br>        prev = temp<br>    <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure></li></ul><h3 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搜索二维矩阵</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 目前的思路是将二维数组展平，然后用二分查找的方法</span><br>    rows, cols = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment"># 对于一个元素i、j来说有这样的关系</span><br>    <span class="hljs-comment"># 一维表示i * rows + cols</span><br>    <span class="hljs-comment"># 那么反过来也是可以找到二维数组的索引的</span><br>    left, right = <span class="hljs-number">0</span>, rows * cols - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt;= right:<br>        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span><br>        x, y = <span class="hljs-built_in">divmod</span>(mid, cols)<br>        <span class="hljs-keyword">if</span> matrix[x][y] == target:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> matrix[x][y] &lt; target:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 寻找峰值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 使用二分查找加速</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]:<br>            right = mid<br>        <span class="hljs-keyword">else</span>:<br>            left = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> left<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 首先写一个简单的算法</span><br>    <span class="hljs-comment"># 遍历数组，找到第一个峰值元素</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i+<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">elif</span> i == <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[i] &gt; nums[i+<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure><h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h3><ul><li>链表中点的寻找</li><li>实际上是对链表进行归并排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 排序链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 使用快慢指针技术来找到链表的中点</span><br>    <span class="hljs-comment"># 利用他们的速度是二倍的关系</span><br>    <span class="hljs-comment"># 奇数：fast == end slow == mid</span><br>    <span class="hljs-comment"># 偶数：fast == end + 1 slow == mid</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>        <span class="hljs-keyword">return</span> head<br><br>    slow, fast = head, head.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>        fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        slow = slow.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-comment"># 切分</span><br>    <span class="hljs-comment"># 解耦链表</span><br>    mid, slow.<span class="hljs-built_in">next</span> = slow.<span class="hljs-built_in">next</span>, <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 递归的机型排序</span><br>    left, right = self.sortList(head), self.sortList(mid)<br><br>    <span class="hljs-keyword">return</span> self.merge(left, right)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:<br>    dummy = ListNode()<br>    tail = dummy<br><br>    <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:<br>        <span class="hljs-keyword">if</span> l1.val &lt; l2.val:<br>            tail.<span class="hljs-built_in">next</span>, l1 = l1, l1.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">else</span>:<br>            tail.<span class="hljs-built_in">next</span>, l2 = l2, l2.<span class="hljs-built_in">next</span><br>        tail = tail.<span class="hljs-built_in">next</span><br><br>    tail.<span class="hljs-built_in">next</span> = l1 <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> l2<br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><ul><li>递归程序的编写<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将有序数组转换为二叉搜索树</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedArrayToBST</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>    <span class="hljs-comment"># 这个题目就是很经典的分治算法</span><br>    <span class="hljs-comment"># 由于是排好序的数组，所以可以直接二分，进行树的构建</span><br>    <span class="hljs-comment"># 先找mid值</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    mid = <span class="hljs-built_in">len</span>(nums) // <span class="hljs-number">2</span><br>    root = TreeNode(nums[mid])<br>    root.left = self.sortedArrayToBST(nums=nums[<span class="hljs-number">0</span>:mid])<br>    <span class="hljs-comment"># nums[mid+1:-1] 从索引 mid+1 处开始截取，但是最后一个元素（索引为 -1 的那个元素）不包括在内。</span><br>    <span class="hljs-comment"># 列表的切片操作是左闭右开的，因此 -1 表示停在倒数第一个元素之前。</span><br>    root.right = self.sortedArrayToBST(nums=nums[mid+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure></li></ul><h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最小路径和</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathSum</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 按照直觉，这个也可以直接对原始数组进行操作</span><br>    rows, cols = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># 按行进行更新</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            <span class="hljs-keyword">if</span> row == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> col != <span class="hljs-number">0</span>:<br>                    grid[row][col] += grid[row][col-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> col == <span class="hljs-number">0</span>:<br>                grid[row][col] += grid[row-<span class="hljs-number">1</span>][col]<br>                <span class="hljs-keyword">continue</span><br><br>            grid[row][col] += <span class="hljs-built_in">min</span>(grid[row][col-<span class="hljs-number">1</span>], grid[row-<span class="hljs-number">1</span>][col])<br>    <span class="hljs-keyword">return</span> grid[rows-<span class="hljs-number">1</span>][cols-<span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure><h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和</a></h3><ul><li>经典动态规划问题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 三角形最小路径和</span><br><span class="hljs-comment"># 二维动态规划</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumTotal</span>(<span class="hljs-params">self, triangle: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 自底向上更新triangle数组，这样能够节省空间</span><br>    n = <span class="hljs-built_in">len</span>(triangle)<br>    <span class="hljs-comment"># 注意：最后一行不需要更新，所以起始是n-1行</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(triangle[row])):<br>            triangle[row][col] += <span class="hljs-built_in">min</span>(triangle[row+<span class="hljs-number">1</span>]<br>                                      [col], triangle[row+<span class="hljs-number">1</span>][col+<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li></ul><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬楼梯</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 创建dp数组</span><br>    dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 初始化dp数组</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>        dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h3><ul><li>注意右边边界的初始索引应该是length - 1<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搜索插入位置</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    mid = (left + right) &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt;= right:<br>        <span class="hljs-keyword">if</span> nums[mid] &lt; target:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> nums[mid] &gt; target:<br>            right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> nums[mid] == target:<br>            <span class="hljs-keyword">return</span> mid<br>        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure></li></ul><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数</a></h3><ul><li>利用位检查或者位消除法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 位检查</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 每次右移一位</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n:<br>        <span class="hljs-comment"># 这里是按位与，1 的前面部分都是0</span><br>        count += n &amp; <span class="hljs-number">1</span><br>        n = n &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br><span class="hljs-comment"># 位清除</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 利用n &amp; n-1去清除最低位的1</span><br>    <span class="hljs-comment"># 可以用这个方法来统计有多少个1（有多少1就要操作多少次）</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n:<br>        n = n &amp; (n-<span class="hljs-number">1</span>)<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure></li></ul><h3 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/">201. 数字范围按位与</a></h3><ul><li>这个题目的解题角度比较刁钻</li><li>例如两个数11100b和11011b两个数</li><li>他们有公共的前缀11，而一个连续的数值区间，一定会有后面的值为0的数，所以按位与之后的结果就是11000b</li><li>那么就变得简单了，只需要记录下向右移动的次数，和最后剩下的前缀，就可以恢复得到最后的结果，bingo~<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数字范围按位与</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rangeBitwiseAnd</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个代码理解起来有点复杂</span><br>    shift = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 找到共同前缀（移动的部分，至少有一个位为0，所以可以直接忽略）</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        left &gt;&gt;= <span class="hljs-number">1</span><br>        right &gt;&gt;= <span class="hljs-number">1</span><br>        shift += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 恢复结果（因为向右边移动了）</span><br>    <span class="hljs-keyword">return</span> left &lt;&lt; shift<br></code></pre></td></tr></table></figure></li></ul><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h3><ul><li>简单的方法：哈希表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 看上去可以用哈希表解决</span><br>    numDict = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        numDict[nums[i]] = numDict.get(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 获取只出现了一次的数字</span><br>    keys = [key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> numDict.items() <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> keys[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li><li>高效的办法：异或运算的性质<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 利用异或运算快速操作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 利用一个数如果与自身异或的结果是0</span><br>    <span class="hljs-comment"># 0与任何数的异或结果都是那个数</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>        res ^= num<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li></ul><h3 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a></h3><ul><li>简单的方法：哈希表</li><li>高效的办法：32位统计每一位出现的次数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只出现一次的数字 II</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目可以换一种方式来思考</span><br>    <span class="hljs-comment"># 首先转换成二进制的位</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-comment"># 检查第i位是否位1</span><br>            <span class="hljs-comment"># 1 &lt;&lt; i表示将1左移i位，即在第i位上的值为1，其他位上的值为0。然后，我们用这个值和num做与操作，如果结果不为0，表明num在第i位上的值为1。</span><br>            <span class="hljs-keyword">if</span> num &amp; (<span class="hljs-number">1</span> &lt;&lt; i):<br>                count += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 对3取余</span><br>        <span class="hljs-comment"># 主要是为了正确设置结果的值</span><br>        res |= (count % <span class="hljs-number">3</span>) &lt;&lt; i <br>    <span class="hljs-comment"># 处理负数</span><br>    <span class="hljs-comment"># 实际上不是32位的，但是人为限定成了32位</span><br>    <span class="hljs-keyword">if</span> res &gt;= <span class="hljs-number">2</span>**<span class="hljs-number">31</span>:<br>        res -= <span class="hljs-number">2</span>**<span class="hljs-number">32</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li><li>超高效的办法：使用真值表求数字电路的表达式（饶了我吧）</li></ul><h3 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a href="https://leetcode.cn/problems/reverse-bits/">190. 颠倒二进制位</a></h3><ul><li>一种低效的算法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 把数字转换成二进制字符串，去除0b</span><br>    binN = <span class="hljs-built_in">bin</span>(n)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">32</span>)<br>    <span class="hljs-comment"># 翻转二进制字符串</span><br>    <span class="hljs-comment"># 切片操作的格式是 [start:stop:step]</span><br>    reverseBinN = binN[::-<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 转换成整数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(reverseBinN, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></li><li>一种高效的算法：分组位翻转算法（解释见[[分组位翻转算法]]）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    n = (n &gt;&gt; <span class="hljs-number">16</span>) | (n &lt;&lt; <span class="hljs-number">16</span>)<br>    n = ((n &amp; <span class="hljs-number">0xff00ff00</span>) &gt;&gt; <span class="hljs-number">8</span>) | ((n &amp; <span class="hljs-number">0x00ff00ff</span>) &lt;&lt; <span class="hljs-number">8</span>)<br>    n = ((n &amp; <span class="hljs-number">0xf0f0f0f0</span>) &gt;&gt; <span class="hljs-number">4</span>) | ((n &amp; <span class="hljs-number">0x0f0f0f0f</span>) &lt;&lt; <span class="hljs-number">4</span>)<br>    n = ((n &amp; <span class="hljs-number">0xcccccccc</span>) &gt;&gt; <span class="hljs-number">2</span>) | ((n &amp; <span class="hljs-number">0x33333333</span>) &lt;&lt; <span class="hljs-number">2</span>)<br>    n = ((n &amp; <span class="hljs-number">0xaaaaaaaa</span>) &gt;&gt; <span class="hljs-number">1</span>) | ((n &amp; <span class="hljs-number">0x55555555</span>) &lt;&lt; <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> n<br></code></pre></td></tr></table></figure></li></ul><h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a href="https://leetcode.cn/problems/add-binary/">67. 二进制求和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二进制求和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addBinary</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">str</span>, b: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 创建结果字符串</span><br>    res = <span class="hljs-string">&#x27;&#x27;</span><br>    lenA, lenB = <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(b)<br>    <span class="hljs-comment"># 一种简单的思路，为了简化计算，向较短的字符串中添加0</span><br>    <span class="hljs-keyword">if</span> lenA &gt; lenB:<br>        b = <span class="hljs-string">&#x27;0&#x27;</span> * (lenA - lenB) + b<br>    <span class="hljs-keyword">else</span>:<br>        a = <span class="hljs-string">&#x27;0&#x27;</span> * (lenB - lenA) + a<br>    <span class="hljs-comment"># 进位</span><br>    carry = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>(lenA,lenB) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span> , -<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">sum</span> = carry + <span class="hljs-built_in">int</span>(a[i]) + <span class="hljs-built_in">int</span>(b[i])<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> == <span class="hljs-number">2</span>:<br>            carry = <span class="hljs-number">1</span><br>            res = <span class="hljs-string">&#x27;0&#x27;</span> + res<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> == <span class="hljs-number">3</span>:<br>            carry = <span class="hljs-number">1</span><br>            res = <span class="hljs-string">&#x27;1&#x27;</span> + res<br>        <span class="hljs-keyword">else</span>:<br>            carry = <span class="hljs-number">0</span><br>            res = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">sum</span>) + res<br>    <span class="hljs-keyword">if</span> carry == <span class="hljs-number">1</span>:<br>        res = <span class="hljs-string">&#x27;1&#x27;</span> + res<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h3><ul><li>这个题目是一个比较经典的回溯算法题目</li><li>两个条件</li><li>（括号的数量如果小于n，说明可以再加</li><li>）括号的数量如果小于左括号，说明可以再加</li><li>终止条件：当括号字符串的长度&#x3D;2 * n<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 伪代码(默写复习)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xxx</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>res = []<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">s, left, right</span>):<br><span class="hljs-keyword">if</span> s == <span class="hljs-number">2</span> * n:<br>res.append(s)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">if</span> left &lt; n:<br>backTrack(s+<span class="hljs-string">&#x27;(&#x27;</span>, left + <span class="hljs-number">1</span>, right)<br><span class="hljs-keyword">if</span> right &lt; left:<br>backTrack(s+<span class="hljs-string">&#x27;)&#x27;</span>, left, right + <span class="hljs-number">1</span>)<br>backTrack(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li><li>代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>    <span class="hljs-comment"># 使用回溯法解决问题</span><br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">2</span> * n:<br>            res.append(s)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 如果左边括号未达到n个，说明还能再加括号</span><br>        <span class="hljs-keyword">if</span> left &lt; n:<br>            backTrack(s + <span class="hljs-string">&quot;(&quot;</span>, left + <span class="hljs-number">1</span>, right)<br>        <span class="hljs-comment"># 如果右边括号没有左边的多，说明需要加闭括号</span><br>        <span class="hljs-keyword">if</span> right &lt; left:<br>            backTrack(s + <span class="hljs-string">&quot;)&quot;</span>, left, right + <span class="hljs-number">1</span>)<br><br>    backTrack(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li></ul><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 电话号码的字母组合</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> digits:<br>        <span class="hljs-keyword">return</span> []<br>    <span class="hljs-comment"># 首先创建一个字母和号码的对应表</span><br>    digit2letter = &#123;<br>        <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;abc&quot;</span>,<br>        <span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-string">&quot;def&quot;</span>,<br>        <span class="hljs-string">&quot;4&quot;</span>: <span class="hljs-string">&quot;ghi&quot;</span>,<br>        <span class="hljs-string">&quot;5&quot;</span>: <span class="hljs-string">&quot;jkl&quot;</span>,<br>        <span class="hljs-string">&quot;6&quot;</span>: <span class="hljs-string">&quot;mno&quot;</span>,<br>        <span class="hljs-string">&quot;7&quot;</span>: <span class="hljs-string">&quot;pqrs&quot;</span>,<br>        <span class="hljs-string">&quot;8&quot;</span>: <span class="hljs-string">&quot;tuv&quot;</span>,<br>        <span class="hljs-string">&quot;9&quot;</span>: <span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;<br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, digits: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(digits) == <span class="hljs-number">0</span>:<br>            res.append(s)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> digit2letter[digits[<span class="hljs-number">0</span>]]:<br>            <span class="hljs-comment"># 回溯后面的字符串</span><br>            backTrack(s+letter, digits[<span class="hljs-number">1</span>:])<br><br>    backTrack(<span class="hljs-string">&#x27;&#x27;</span>, digits)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h3><ul><li>4&#x2F;17复习<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 组合</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</span><br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> []<br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">current: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], start: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(current) == k:<br>            <span class="hljs-comment"># 使用切片复制一份</span><br>            res.append(current[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n + <span class="hljs-number">1</span>):<br>            current.append(i)<br>            backTrack(current, i + <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># 恢复状态</span><br>            current.pop()<br><br>    backTrack([], <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li></ul><h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h3><ul><li>4&#x2F;17复习 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单词搜索</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exist</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    col, row = <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]), <span class="hljs-built_in">len</span>(board)<br><br>    <span class="hljs-comment"># 定义一下搜索方向</span><br>    direct = [(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)]<br>    <span class="hljs-comment"># 创建visited数组</span><br>    visited = [[<span class="hljs-literal">False</span>] * col <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y, index</span>):<br><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(word):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 判断是否越界</span><br>        <span class="hljs-comment"># 判断条件有点多呀</span><br>        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> x &gt;= row <span class="hljs-keyword">or</span> y &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> y &gt;= col <span class="hljs-keyword">or</span> board[x][y] != word[index] <span class="hljs-keyword">or</span> visited[x][y]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 检查下一个</span><br>        visited[x][y] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> direct:<br>            <span class="hljs-keyword">if</span> dfs(x+item[<span class="hljs-number">0</span>], y+item[<span class="hljs-number">1</span>], index + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        visited[x][y] = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>            <span class="hljs-keyword">if</span> dfs(i, j, <span class="hljs-number">0</span>):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 组合总和</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> candidates:<br>        <span class="hljs-keyword">return</span> []<br><br>    res = []<br>    candidates.sort()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">start, target, path</span>):<br>        <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span>:<br>            res.append(path[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, <span class="hljs-built_in">len</span>(candidates)):<br>            <span class="hljs-keyword">if</span> candidates[i] &gt; target:<br>                <span class="hljs-keyword">break</span><br>            path.append(candidates[i])<br>            backTrack(i, target - candidates[i], path)<br>            path.pop()<br><br>    backTrack(<span class="hljs-number">0</span>, target, [])<br><br>    <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">pass</span><br><br></code></pre></td></tr></table></figure><ul><li>下面的代码有问题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下面的代码有问题不能去除重复</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> candidates:<br>        <span class="hljs-keyword">return</span> []<br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">cur, candidates</span>):<br>        <span class="hljs-comment"># 判断是否到了target</span><br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cur:<br>            <span class="hljs-built_in">sum</span> += i<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> == target:<br>            <span class="hljs-keyword">if</span> cur <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res:<br>                res.append(cur[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> &gt; target:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> candidates:<br>                cur.append(i)<br>                backTrack(cur, candidates)<br>                cur.pop()<br>    backTrack([], candidates)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 全排列</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>        <span class="hljs-keyword">return</span> []<br><br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">cur, last</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cur) == <span class="hljs-built_in">len</span>(nums):<br>            res.append(cur[:])<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> last:<br>            cur.append(i)<br>            <span class="hljs-comment"># 回溯</span><br>            nextRemain = last[:]<br>            nextRemain.remove(i)<br>            backTrack(cur, nextRemain)<br>            cur.pop()<br><br>    backTrack([], nums)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除排序链表中的重复元素 II</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 一看就是双指针</span><br>    <span class="hljs-comment"># 创建一个附加头节点</span><br>    dummy = ListNode(-<span class="hljs-number">1</span>,head)<br>    prev = dummy<br>    <span class="hljs-comment"># prev始终是head的前一个结点</span><br>    <span class="hljs-keyword">while</span> head:<br>        <span class="hljs-keyword">if</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> head.val ==head.<span class="hljs-built_in">next</span>.val:<br>            <span class="hljs-comment"># 跳过所有重复节点</span><br>            <span class="hljs-keyword">while</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> head.val == head.<span class="hljs-built_in">next</span>.val:<br>                head = head.<span class="hljs-built_in">next</span> <br>            <span class="hljs-comment"># 再跳一个</span><br>            head = head.<span class="hljs-built_in">next</span><br>            prev.<span class="hljs-built_in">next</span> = head<br>        <span class="hljs-keyword">else</span>:<br>            prev = prev.<span class="hljs-built_in">next</span> <br>            head = head.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 反转链表 II</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> left == right:<br>        <span class="hljs-keyword">return</span> head<br><br>    dummy = ListNode(<span class="hljs-number">0</span>, head)<br>    prev = dummy<br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left - <span class="hljs-number">1</span>):<br>        prev = prev.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-comment"># start</span><br>    start = prev.<span class="hljs-built_in">next</span><br>    then = start.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(right - left):<br>        <span class="hljs-comment"># 反转链表</span><br>        start.<span class="hljs-built_in">next</span> = then.<span class="hljs-built_in">next</span><br>        then.<span class="hljs-built_in">next</span> = prev.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = then<br>        then = start.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br><br></code></pre></td></tr></table></figure><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 合并两个有序链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 处理空表情况</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> list1:<br>        <span class="hljs-keyword">return</span> list2<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> list2:<br>        <span class="hljs-keyword">return</span> list1<br>    <span class="hljs-comment"># 定义新的链表</span><br>    <span class="hljs-comment"># 定义新的链表的伪头节点</span><br>    dummy = ListNode(-<span class="hljs-number">1</span>)<br>    res = dummy<br><br>    <span class="hljs-comment"># 当两个链表都不为空时，比较当前节点，并连接值较小的节点</span><br>    <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>        <span class="hljs-keyword">if</span> list1.val &lt; list2.val:<br>            res.<span class="hljs-built_in">next</span> = list1<br>            list1 = list1.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">else</span>:<br>            res.<span class="hljs-built_in">next</span> = list2<br>            list2 = list2.<span class="hljs-built_in">next</span><br>        res = res.<span class="hljs-built_in">next</span><br>    <span class="hljs-comment"># 如果某一个链表已为空，直接将非空链表的剩余部分连接到新链表</span><br>    res.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">else</span> list2<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h3><ul><li>4&#x2F;17复习<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 环形链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 如何检测链表中有没有环</span><br>    <span class="hljs-comment"># 使用快慢指针！一个移动1个，一个移动2个，如果他们总会相遇，则说明有环</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    slow = head<br>    fast = head.<span class="hljs-built_in">next</span>()<br><br>    <span class="hljs-keyword">while</span> slow != fast:<br>        <span class="hljs-comment"># 如果快指针走到头了 说明没必要走了</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> fast <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> fast.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        slow = slow.<span class="hljs-built_in">next</span><br>        fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3><ul><li>4&#x2F;17复习</li><li>为什么贪心不行？因为可能使用最大的面值最大数量导致最后不够分了，并不是最优解</li><li>什么时候贪心可以？<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 零钱兑换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coinChange</span>(<span class="hljs-params">self, coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], amount: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目一眼动态规划 二眼贪心</span><br><br>    <span class="hljs-comment"># 创建dp数组</span><br>    <span class="hljs-comment"># 含义 要达到i金额最小的硬币数量</span><br>    dp = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * (amount + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 初始化dp数组</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 按照硬币来遍历</span><br>    <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(coin, amount + <span class="hljs-number">1</span>):<br>            dp[x] = <span class="hljs-built_in">min</span>(dp[x], dp[x-coin] + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 最后返回最后一个值</span><br>    <span class="hljs-keyword">return</span> dp[amount] <span class="hljs-keyword">if</span> dp[amount] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h3><ul><li>4&#x2F;17复习<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 一个简单的动态规划问题</span><br>    <span class="hljs-comment"># 首先初始化dp数组和dict集合</span><br>    wordSet = <span class="hljs-built_in">set</span>(wordDict)<br>    dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> dp[j] <span class="hljs-keyword">and</span> s[j:i] <span class="hljs-keyword">in</span> wordSet:<br>                dp[i] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br></code></pre></td></tr></table></figure></li><li>原始代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单词拆分</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 一个简单的动态规划问题</span><br>    <span class="hljs-comment"># 初始化dp数组</span><br>    <span class="hljs-comment"># 建议将wordDict转换为集合，这样在查找时可以实现更快的操作，集合的查找时间复杂度是O(1)。</span><br>    wordSet = <span class="hljs-built_in">set</span>(wordDict)<br>    dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)<br><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> dp[j] <span class="hljs-keyword">and</span> s[j:i] <span class="hljs-keyword">in</span> wordSet:<br>                dp[i] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br></code></pre></td></tr></table></figure></li></ul><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 合并区间</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 这个题的目的是合并重叠的区间</span><br>    <span class="hljs-comment"># 感觉可以先对数组进行一次排序，然后再根据情况合并</span><br>    intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])<br>    start, end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    res = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(intervals)):<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &lt;= end:<br>            <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">1</span>] &gt;= end: <br>                end = intervals[i][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            res.append([start, end])<br>            start = intervals[i][<span class="hljs-number">0</span>]<br>            end = intervals[i][<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 对最后一个进行特判</span><br>    res.append([start, end])<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a><a href="https://leetcode.cn/problems/summary-ranges/">228. 汇总区间</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 汇总区间</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">summaryRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:  <span class="hljs-comment"># 处理空数组</span><br>        <span class="hljs-keyword">return</span> []<br><br>    res = []<br>    start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>  <span class="hljs-comment"># 初始化为第一个元素的下标</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> nums[i] == nums[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>:<br>            end = i  <span class="hljs-comment"># 更新范围的结束</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前数字不是连续的，保存到目前为止的范围</span><br>            <span class="hljs-keyword">if</span> start == end:  <span class="hljs-comment"># 单个元素的范围</span><br>                res.append(<span class="hljs-built_in">str</span>(nums[start]))<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 连续元素的范围</span><br>                res.append(<span class="hljs-built_in">str</span>(nums[start]) + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">str</span>(nums[end]))<br>            start, end = i, i  <span class="hljs-comment"># 更新范围到新的开始地点</span><br><br>    <span class="hljs-comment"># 循环结束后，检查并添加最后一个范围</span><br>    <span class="hljs-keyword">if</span> start == end:  <span class="hljs-comment"># 单个元素的范围</span><br>        res.append(<span class="hljs-built_in">str</span>(nums[start]))<br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 连续元素的范围</span><br>        res.append(<span class="hljs-built_in">str</span>(nums[start]) + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">str</span>(nums[end]))<br><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h3><ul><li>这个题目<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 矩阵置零</span><br><span class="hljs-comment"># 性能比较差的解法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 感觉这个题的思路是：先记录下需要改变的行和列，最后统一置0</span><br>    rowSet = <span class="hljs-built_in">set</span>()<br>    colSet = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                rowSet.add(i)<br>                colSet.add(j)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> rowSet:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[item])):<br>            matrix[item][i] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> colSet:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            matrix[j][item] = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h3><ul><li>开始想复杂了，实际上比较简单</li><li>就是一个转置+水平翻转<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 旋转图像</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 原来旋转=转置+翻转行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>    <span class="hljs-comment"># 翻转行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>        matrix[i].reverse()<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></h3><ul><li>两种解法：哈希表（和两数之和有点像）、滑动窗口+set<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 创建一个记录坐标的哈希表</span><br>    posDict = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">in</span> posDict <span class="hljs-keyword">and</span> i - posDict[nums[i]] &lt;= k:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        posDict[nums[i]] = i<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></li><li>滑动窗口的解法（很巧妙呀）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 滑动窗口</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    s = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>        <span class="hljs-comment"># 超过窗口就移除之前那个</span><br>        <span class="hljs-keyword">if</span> i &gt; k:<br>            s.remove(nums[i-k-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        s.add(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a href="https://leetcode.cn/problems/word-pattern/">290. 单词规律</a></h3><ul><li>和205简直一模一样</li><li>也是需要创建双向映射<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单词规律</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wordPattern</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 创建一个映射哈希表</span><br>    sArr = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    sLen, tLen = <span class="hljs-built_in">len</span>(sArr), <span class="hljs-built_in">len</span>(pattern)<br>    <span class="hljs-keyword">if</span> sLen != tLen:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 创建两个哈希表</span><br>    s2t = &#123;&#125;<br>    t2s = &#123;&#125;<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sLen):<br>        charS, charT = pattern[i], sArr[i]<br><br>        <span class="hljs-keyword">if</span> charS <span class="hljs-keyword">in</span> s2t <span class="hljs-keyword">and</span> s2t[charS] != charT:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> charT <span class="hljs-keyword">in</span> t2s <span class="hljs-keyword">and</span> t2s[charT] != charS:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        s2t[charS] = charT<br>        t2s[charT] = charS<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure></li></ul><h3 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a><a href="https://leetcode.cn/problems/isomorphic-strings/">205. 同构字符串</a></h3><ul><li>注意读题啊！</li><li>首先需要理解什么是同构字符串—两个字符串中的单词映射应当是唯一的，而不是相差的距离一样<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 同构字符串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isIsomorphic</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    sLen, tLen = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(t)<br>    <span class="hljs-keyword">if</span> sLen != tLen:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-comment"># 创建两个哈希表</span><br>    s2t = &#123;&#125;<br>    t2s = &#123;&#125;<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sLen):<br>        charS,charT = s[i],t[i]<br><br>        <span class="hljs-keyword">if</span> charS <span class="hljs-keyword">in</span> s2t <span class="hljs-keyword">and</span> s2t[charS] != charT:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> charT <span class="hljs-keyword">in</span> t2s <span class="hljs-keyword">and</span> t2s[charT] != charS:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        s2t[charS] = charT<br>        t2s[charT] = charS<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h3><ul><li>乍一看很简单，两个指针，一个指向s，一个指向t，慢慢遍历。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubsequence</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 创建两个指针分别指向s、t</span><br>    sPointer, tPointer = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> sPointer &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> tPointer &lt; <span class="hljs-built_in">len</span>(t):<br>        <span class="hljs-keyword">if</span> s[sPointer] == t[tPointer]:<br>            sPointer += <span class="hljs-number">1</span><br>            tPointer += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            tPointer += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> sPointer == <span class="hljs-built_in">len</span>(s):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><strong>进阶：</strong><br>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</li></ul><h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h3><ul><li>一个非常简单的双指针<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 两数之和 II - 输入有序数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, numbers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-comment"># 感觉可以用双指针</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        <span class="hljs-keyword">if</span> numbers[left] + numbers[right] == target:<br>            <span class="hljs-keyword">return</span> [left+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">elif</span> numbers[left] + numbers[right] &gt; target:<br>            right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure></li></ul><h3 id="149-直线上最多的点数"><a href="#149-直线上最多的点数" class="headerlink" title="149. 直线上最多的点数"></a><a href="https://leetcode.cn/problems/max-points-on-a-line/">149. 直线上最多的点数</a></h3><ul><li>注意点：斜率的处理（特殊情况、正负数）</li><li>思考点：只考虑斜率，不考虑截距不会出问题吗？<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直线上最多的点数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPoints</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 两点确定一条直线，所以可以计算两两之间的斜率？</span><br>    <span class="hljs-comment"># 使用哈希表计算所有可能的斜率？</span><br>    <span class="hljs-comment"># 斜率计算函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getSlope</span>(<span class="hljs-params">p1, p2</span>):<br>        dx, dy = p2[<span class="hljs-number">0</span>] - p1[<span class="hljs-number">0</span>], p2[<span class="hljs-number">1</span>] - p1[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 特殊情况</span><br>        <span class="hljs-comment"># 斜率无穷大</span><br>        <span class="hljs-keyword">if</span> dx == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;inf&#x27;</span><br>        <span class="hljs-comment"># 斜率为0</span><br>        <span class="hljs-keyword">if</span> dy == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 约分，保持精度</span><br>        <span class="hljs-comment"># 同时除以最大公约数</span><br>        d = gcd(dx, dy)<br>        <span class="hljs-comment"># 如果是负数，需要统一，防止-1 / 2 和 1 / -2 不一样</span><br>        <span class="hljs-keyword">if</span> dy &lt; <span class="hljs-number">0</span>:<br>            dy = -dy<br>            dx = -dx<br>        <span class="hljs-keyword">return</span> (dy // d, dx // d)<br><br>    result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(points)):<br>        slopeDict = defaultdict(<span class="hljs-built_in">int</span>)<br>        duplicate = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(points)):<br>            <span class="hljs-keyword">if</span> points[i] == points[j]:<br>                duplicate += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            slope = getSlope(points[i], points[j])<br>            slopeDict[slope] += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 当前的最大值为重复点+max 斜率value</span><br>        result = <span class="hljs-built_in">max</span>(result, (<span class="hljs-built_in">max</span>(slopeDict.values())<br>                     <span class="hljs-keyword">if</span> slopeDict <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + duplicate)<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li></ul><h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h3><ul><li>找质因子10的个数，转换为2*5的个数，由于5比2的多，所以直接找5的</li><li>首先从5开始数，找5的倍数，5的倍数进行分解，看看有多少个因子5<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 阶乘后的零</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">trailingZeroes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 思路很难想到 质因子为10的个数</span><br>    <span class="hljs-comment"># 10 = 2 x 5</span><br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, n + <span class="hljs-number">1</span>, <span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">while</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>            i //= <span class="hljs-number">5</span><br>            ans += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure></li></ul><h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h3><ul><li>思路：去除前后空格 -&gt; 翻转整个串  -&gt; 按’ ‘进行split -&gt; 翻转每个单词 -&gt; 重新整合成串<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 反转字符串中的单词</span><br><span class="hljs-comment"># 不优雅版本</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">import</span> re<br>    sPie = re.sub(<span class="hljs-string">r&#x27;\s+&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, s).strip()[::-<span class="hljs-number">1</span>]<br>    sReverse = sPie[::-<span class="hljs-number">1</span>]<br>    sArr = sReverse.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    sArrAfter = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sArr:<br>        sArrAfter.append(i[::-<span class="hljs-number">1</span>])<br>    res = <span class="hljs-string">&#x27; &#x27;</span>.join(sArrAfter)<br>    <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-comment"># 优雅版</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">import</span> re<br>    sPie = re.sub(<span class="hljs-string">r&#x27;\s+&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, s).strip()<br>    word = sPie.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    wordReverse = [item[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> word]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(wordReverse)<br></code></pre></td></tr></table></figure></li></ul><h3 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></h3><ul><li>数组+哈希表</li><li>各司其责，主要的难点在于删除</li><li>删除的时候，移动要删除的元素到数组末尾，再pop，时间复杂度降到最低！<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># O(1) 时间插入、删除和获取随机元素</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span>:<br>    <span class="hljs-comment"># Your RandomizedSet object will be instantiated and called as such:</span><br>    <span class="hljs-comment"># obj = RandomizedSet()</span><br>    <span class="hljs-comment"># param_1 = obj.insert(val)</span><br>    <span class="hljs-comment"># param_2 = obj.remove(val)</span><br>    <span class="hljs-comment"># param_3 = obj.getRandom()</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 创建数组和哈希表</span><br>        self.numList = []<br>        self.numDict = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 插入元素直接插入到数组</span><br>        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">in</span> self.numDict:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        self.numDict[val] = <span class="hljs-built_in">len</span>(self.numList)<br>        self.numList.append(val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 删除元素比较难</span><br>        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.numDict:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 思路是什么？</span><br>        <span class="hljs-comment"># 将要删那个数变成数组中的最后一个数！~太妙了</span><br>        <span class="hljs-comment"># 获取要删除的值的索引，并将其与列表中的最后一个元素交换</span><br>        index = self.numDict[val]<br>        lastVal = self.numList[-<span class="hljs-number">1</span>]<br>        self.numList[index] = lastVal<br>        self.numDict[lastVal] = index<br>        <span class="hljs-comment"># 删除数组中最后一个元素</span><br>        self.numList.pop()<br>        <span class="hljs-keyword">del</span> self.numDict[val]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRandom</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> random.choice(self.numList)<br></code></pre></td></tr></table></figure></li></ul><h3 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274. H 指数"></a><a href="https://leetcode.cn/problems/h-index/">274. H 指数</a></h3><ul><li>一个朴素的思想<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hIndex</span>(<span class="hljs-params">self, citations: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 看了之后就是先排序</span><br>    citations.sort(reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(citations)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(citations)):<br>        <span class="hljs-comment"># 找到一个index+1 &lt; citations[index]的值</span><br>        <span class="hljs-keyword">if</span> i + <span class="hljs-number">1</span> &gt; citations[i]:<br>            <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(citations)<br></code></pre></td></tr></table></figure></li></ul><h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3><ul><li>思考一下我的代码为什么这么拉跨（想必答案就是缺乏思考哈哈哈哈 形成了闭环）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 感觉是找上升序列的问题</span><br>    <span class="hljs-comment"># 找出所有的上升序列即可</span><br>    <span class="hljs-comment"># 标记上升序列的长度</span><br>    start,end = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>    isUp = <span class="hljs-number">0</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>        <span class="hljs-keyword">if</span> prices[i] &gt;= prices[i-<span class="hljs-number">1</span>]:<br>            isUp = <span class="hljs-number">1</span><br>            end += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            res += prices[end] - prices[start]<br>            start = end+<span class="hljs-number">1</span><br>            end = start<br>            isUp = <span class="hljs-number">0</span><br>    res += prices[end] - prices[start]<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li><li>优雅的代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 优雅的代码就是不一样</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    profit = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 遍历价格数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>        <span class="hljs-comment"># 如果今天的价格比昨天高，就认为可以进行一次交易</span><br>        <span class="hljs-keyword">if</span> prices[i] &gt; prices[i-<span class="hljs-number">1</span>]:<br>            profit += prices[i] - prices[i-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> profit<br></code></pre></td></tr></table></figure></li></ul><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><ul><li>看了以前写的代码写出来了</li><li>核心思想是维护两个变量</li><li>如果有多只股票呢<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 关键就是遍历与维护变量</span><br>    cost = sys.maxsize<br>    profit = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> prices:<br>        <span class="hljs-keyword">if</span> item &lt; cost:<br>            cost = item<br>        <span class="hljs-keyword">if</span> item - cost &gt; profit:<br>            profit = item - cost<br>    <span class="hljs-keyword">return</span> profit<br></code></pre></td></tr></table></figure></li></ul><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和</a></h3><ul><li>思考这和传统“三数之和”有什么区别？</li><li>本题说明：最后只包含一个解，所以不需要考虑去重<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最接近的三数之和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 三数之和的简化版</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 首先对数组进行排序</span><br>    nums.sort()<br>    minSub = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] - target<br><br>    <span class="hljs-comment"># 首先固定一个元素 然后进行双指针</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        left, right = i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            sumThree = nums[i] + nums[left] + nums[right]<br>            minSub = sumThree-target <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(sumThree - target) &lt;= <span class="hljs-built_in">abs</span>(minSub) <span class="hljs-keyword">else</span> minSub<br>            <span class="hljs-keyword">if</span> sumThree &gt; target:<br>                right -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> sumThree &lt; target:<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> minSub + target<br>    <span class="hljs-keyword">return</span> minSub + target<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配</a></h3><p>这个问题是一个经典的动态规划（Dynamic Programming，DP）问题，你正在尝试实现一个匹配字符串 <code>s</code> 和模式 <code>p</code> 的函数。在这种情况下，模式 <code>p</code> 可以包含普通字符和两个特殊字符:</p><ol><li><code>.</code> - 可以匹配任何单个字符</li><li><code>*</code> - 匹配零个或多个前面的那一个元素<br>![[Pasted image 20240402211458.png]]<br>这种情况下：<code>dp[i][j] = dp[i-2][j]</code><br>![[Pasted image 20240402211440.png]]<br>这种情况下：<code>dp[i][j] = dp[i][j-1]</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    l1, l2 = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br>    dp = [[<span class="hljs-literal">False</span>] * (l1+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l2+<span class="hljs-number">1</span>)]<br>    <span class="hljs-comment"># 初始化dp数组</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, l2+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> p[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>            dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 开始dp过程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l1+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> p[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                <span class="hljs-keyword">if</span> p[i-<span class="hljs-number">2</span>] == s[j-<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> p[i-<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>:<br>                    <span class="hljs-comment"># a * 出现1次或多次</span><br>                    dp[i][j] = dp[i][j-<span class="hljs-number">1</span>]<br>                <span class="hljs-comment"># a * 可匹配0次</span><br>                <span class="hljs-comment"># 如果之前 dp[i][j] 已经是 True，或者如果消掉 *（和它前面的字符）后能够匹配 (dp[i-2][j] 是 True), 那么 dp[i][j] 应该为 True</span><br>                <span class="hljs-comment"># 等价于dp[i][j] = dp[i][j] or dp[i-2][j]</span><br>                dp[i][j] |= dp[i-<span class="hljs-number">2</span>][j]<br>            <span class="hljs-keyword">elif</span> p[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> p[i-<span class="hljs-number">1</span>] == s[j-<span class="hljs-number">1</span>]:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[l2][l1]<br></code></pre></td></tr></table></figure></li></ol><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></h3><ul><li>简单题</li><li>注意边界条件的判定<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> strs:  <span class="hljs-comment"># 检查 strs 是否为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(strs[<span class="hljs-number">0</span>])):<br>        cur = strs[<span class="hljs-number">0</span>][i]<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> strs[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-comment"># 需要判断长度是否合适</span><br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(item) <span class="hljs-keyword">or</span> item[i] != cur:<br>                <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>][: i]<br>    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li></ul><h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h3><ul><li>一步一步递推的公式<a href="https://www.bilibili.com/video/BV15h411Z7Qd/?spm_id_from=333.337.search-card.all.click&vd_source=d9475db036bd1ced8053fd2ce6353ceb">编辑距离 - 动态规划解法 Edit Distance - Dynamic Programming_哔哩哔哩_bilibili</a><br>![[Pasted image 20240401142732.png]]</li><li>注意：<br><code>dp = [[0] * l1] * l2</code><br>这行代码创建了一个二维数组 <code>dp</code>，但方式不正确。因为 <code>[[0] * l1] * l2</code> 这种方式复制的是同一个列表的引用。当你修改任意一个 <code>dp[j][i]</code> 的值时，<code>dp</code> 的每一行都会被改变，因为它们实际上是同一个列表的引用。<br>应该用这个<code>dp = [[0] * l1 for _ in range(l2)]</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 创建dp数组</span><br>    l1, l2 = <span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span><br><br>    dp = [[<span class="hljs-number">0</span>] * l1 <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l2)]<br>    <span class="hljs-comment"># 初始化dp数组的第一行和第一列</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l1):<br>        dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2):<br>        dp[j][<span class="hljs-number">0</span>] = dp[j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 进行dp</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l1):<br>            <span class="hljs-comment"># 这里需要考虑边界条件，因为i和j包含了空字符串的情况，因此需要-1</span><br>            <span class="hljs-keyword">if</span> word2[i-<span class="hljs-number">1</span>] == word1[j-<span class="hljs-number">1</span>]:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 两个不相同</span><br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i]<br>                               [j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> dp[l2-<span class="hljs-number">1</span>][l1-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li></ul><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h3><ul><li>左右数组进行分别遍历<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    left, right = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(height), [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(height)<br>    <span class="hljs-comment"># 首先遍历左边，看左边的最大高度</span><br>    maxLeft = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(height)):<br>        <span class="hljs-keyword">if</span> maxLeft &lt; height[i - <span class="hljs-number">1</span>]:<br>            maxLeft = height[i - <span class="hljs-number">1</span>]<br>        left[i] = maxLeft<br>    maxRight = height[<span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(height) - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> maxRight &lt; height[j + <span class="hljs-number">1</span>]:<br>            maxRight = height[j + <span class="hljs-number">1</span>]<br>        right[j] = maxRight<br><br>    <span class="hljs-comment"># 遍历</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span>):<br>        res += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(right[k], left[k]) - height[k])<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li><li>双指针？</li></ul><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h3><ul><li>这个题目特别的经典</li><li>但是我已经忘了怎么做了</li><li>参考一下coze的思路</li><li>首先进行排序，固定第一个数的index</li><li>然后使用双指针l、r对剩下的数进行筛选<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 和为0的话</span><br>    <span class="hljs-comment"># 原地排序</span><br>    nums.sort()<br>    result = []<br>    <span class="hljs-comment"># 我的思路是先固定一个数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">2</span>):<br>        <span class="hljs-comment"># 剩下的就是两数之和问题了</span><br>        <span class="hljs-comment"># 如果不是第一个数</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]:<br>            <span class="hljs-comment"># 跳过重复值</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-comment"># 双指针</span><br>        l, r = i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            total = nums[i] + nums[l] + nums[r]<br>            <span class="hljs-keyword">if</span> total &lt; <span class="hljs-number">0</span>:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> total &gt; <span class="hljs-number">0</span>:<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append([nums[i],nums[l],nums[r]])   <br>                <span class="hljs-comment"># 去重复</span><br>                <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l + <span class="hljs-number">1</span>]: l+=<span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> l&lt; r <span class="hljs-keyword">and</span> nums[r] == nums[r-<span class="hljs-number">1</span>]:r-=<span class="hljs-number">1</span><br>                l+=<span class="hljs-number">1</span><br>                r-=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li></ul><h3 id="3083-字符串及其反转中是否存在同一子字符串"><a href="#3083-字符串及其反转中是否存在同一子字符串" class="headerlink" title="3083. 字符串及其反转中是否存在同一子字符串"></a><a href="https://leetcode.cn/problems/existence-of-a-substring-in-a-string-and-its-reverse/">3083. 字符串及其反转中是否存在同一子字符串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubstringPresent</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 创建一个set</span><br>    st = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> pairwise(s):<br>        st.add((x, y))<br>        <span class="hljs-keyword">if</span> (y, x) <span class="hljs-keyword">in</span> st:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="3084-统计以给定字符开头和结尾的子字符串总数"><a href="#3084-统计以给定字符开头和结尾的子字符串总数" class="headerlink" title="3084. 统计以给定字符开头和结尾的子字符串总数"></a><a href="https://leetcode.cn/problems/count-substrings-starting-and-ending-with-given-character/">3084. 统计以给定字符开头和结尾的子字符串总数</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">countSubstrings</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, c: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 遍历一次 查看c出现的次数</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> item == c:<br>            count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> (count*(count+<span class="hljs-number">1</span>))//<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="2697-字典序最小回文串"><a href="#2697-字典序最小回文串" class="headerlink" title="2697. 字典序最小回文串"></a><a href="https://leetcode.cn/problems/lexicographically-smallest-palindrome/">2697. 字典序最小回文串</a></h3><ul><li>朴素的想法</li><li>实际上不是我的想法，而是灵神的想法哈哈哈<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字典序最小回文串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">makeSmallestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 朴素的想法 使用哈希表 找到出现次数不是单数的（中间的不算）</span><br>    <span class="hljs-comment"># 然而事实证明 想得太复杂了</span><br>    <span class="hljs-comment"># 只需要一次遍历就好了</span><br>    sList = <span class="hljs-built_in">list</span>(s)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) // <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">if</span> sList[i] &gt; sList[<span class="hljs-built_in">len</span>(s) - i - <span class="hljs-number">1</span>]:<br>            sList[i] = sList[<span class="hljs-built_in">len</span>(s) - i - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">elif</span> sList[i] &lt; sList[<span class="hljs-built_in">len</span>(s) - i - <span class="hljs-number">1</span>]:<br>            sList[<span class="hljs-built_in">len</span>(s) - i - <span class="hljs-number">1</span>] = sList[i]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(sList)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2375-根据模式串构造最小数字"><a href="#2375-根据模式串构造最小数字" class="headerlink" title="2375. 根据模式串构造最小数字"></a><a href="https://leetcode.cn/problems/construct-smallest-number-from-di-string/">2375. 根据模式串构造最小数字</a></h3><ul><li>先回忆一下灵神讲得东西</li><li>实际上采用的策略是贪心<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据模式串构造最小数字</span><br><span class="hljs-comment"># 下面是抄的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smallestNumber</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 根据灵神的思路</span><br>    n = <span class="hljs-built_in">len</span>(pattern)<br>    <span class="hljs-comment"># digits = &#x27;0123456789&#x27;</span><br>    <span class="hljs-built_in">print</span>(digits)<br>    ans = <span class="hljs-built_in">list</span>(digits[<span class="hljs-number">1</span>:n+<span class="hljs-number">2</span>])<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; n:<br>        <span class="hljs-comment"># 如果处于升序</span><br>        <span class="hljs-keyword">if</span> pattern[i] == <span class="hljs-string">&#x27;I&#x27;</span>:<br>            i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">continue</span><br>        i0 = i<br>        i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> pattern[i] == <span class="hljs-string">&#x27;D&#x27;</span>:<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 反转</span><br>    <br>        ans[i0:i+<span class="hljs-number">1</span>] = ans[i0:i+<span class="hljs-number">1</span>][::-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(ans)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2374-边积分最高的节点"><a href="#2374-边积分最高的节点" class="headerlink" title="2374. 边积分最高的节点"></a><a href="https://leetcode.cn/problems/node-with-highest-edge-score/">2374. 边积分最高的节点</a></h3><ul><li>使用一种优雅的做法（来自灵神）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 边积分最高的节点</span><br><span class="hljs-comment"># 一下子从吊车尾的时空占有情况提升到前面，果然代码还得是要优化啊</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edgeScore</span>(<span class="hljs-params">self, edges: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 定义一个score数组 和 最后的maxKey</span><br>    maxKey,maxVal, score = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, [<span class="hljs-number">0</span>]* <span class="hljs-built_in">len</span>(edges)<br>    <span class="hljs-comment"># 一次遍历搞定</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(edges)):<br>        to = edges[i]<br>        score[to] = score[to] + i<br>        <span class="hljs-keyword">if</span> score[to] &gt; maxVal <span class="hljs-keyword">or</span> (score[to]==maxVal <span class="hljs-keyword">and</span> to &lt; maxKey):<br>            maxKey = to <br>            maxVal = score[to]<br>    <span class="hljs-keyword">return</span> maxKey<br></code></pre></td></tr></table></figure></li><li>有点脱裤子放屁的做法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 边积分最高的节点</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edgeScore</span>(<span class="hljs-params">self, edges: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 首先明确边积分的定义:</span><br>    <span class="hljs-comment"># 指向节点i的所有边的起始编号之和</span><br>    <span class="hljs-comment"># 朴素的想法是使用map</span><br>    degree = OrderedDict()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(edges)):<br>        degree[edges[i]] = i + degree.get(edges[i], <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 取最大的key,但是这里的key其实是没有排序的,所以会有问题</span><br>    maxKey = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> degree.keys():<br>        <span class="hljs-keyword">if</span> degree.get(maxKey, -<span class="hljs-number">1</span>) &lt; degree[key] <span class="hljs-keyword">or</span> (degree.get(maxKey, -<span class="hljs-number">1</span>) == degree[key] <span class="hljs-keyword">and</span> maxKey &gt; key):<br>            maxKey = key<br><br>    <span class="hljs-keyword">return</span> maxKey<br></code></pre></td></tr></table></figure></li></ul><h3 id="2373-矩阵中的局部最大值"><a href="#2373-矩阵中的局部最大值" class="headerlink" title="2373. 矩阵中的局部最大值"></a><a href="https://leetcode.cn/problems/largest-local-values-in-a-matrix/">2373. 矩阵中的局部最大值</a></h3><ul><li>实际上就是深度学习中的Maxpooling操作<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 矩阵中的局部最大值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">largestLocal</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 基本思想是将每次计算的值放在左上角</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid) - <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid) - <span class="hljs-number">2</span>):<br>            <span class="hljs-comment"># 计算3 * 3矩阵的最大值</span><br>            <span class="hljs-comment"># 请我不要犯傻了，这么简单的问题都要错</span><br>            <span class="hljs-comment"># 首先不要重复使用循环变量♻️</span><br>            <span class="hljs-comment"># 其次，不要只在内层最大值求整行的最大值，而是窗口内的最大值</span><br>            <span class="hljs-comment"># 都没有使用到变量j,怎么会得到正确答案呢?</span><br>            grid[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>([item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> grid[k][j:j+<span class="hljs-number">3</span>]])<br>                             <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, i+<span class="hljs-number">3</span>))<br>        grid[i].pop()<br>        grid[i].pop()<br>    grid.pop()<br>    grid.pop()<br>    <span class="hljs-keyword">return</span> grid<br></code></pre></td></tr></table></figure></li></ul><h3 id="200-岛屿数量-1"><a href="#200-岛屿数量-1" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h3><ul><li>使用dfs深度优先遍历，本质上是递归<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不含连续1的非负整数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>        <span class="hljs-comment"># 请注意i和j的索引范围，一定要包含等号！！！</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= <span class="hljs-built_in">len</span>(grid) <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            <span class="hljs-keyword">return</span><br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>        dfs(i+<span class="hljs-number">1</span>, j)<br>        dfs(i-<span class="hljs-number">1</span>, j)<br>        dfs(i, j+<span class="hljs-number">1</span>)<br>        dfs(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 如果grid = null直接返回</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-comment"># 这一步会把所有临近的陆地标记成为海洋，一举两得</span><br>                dfs(i, j)<br>                count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure></li></ul><h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h3><ul><li>好久没做了，想到了解法的一半（纯纯凭直觉做的）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分发糖果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">candy</span>(<span class="hljs-params">self, ratings: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 看到相邻问题 直接使用左右两个数组</span><br>    <span class="hljs-comment"># 需要注意的是 左右两边只能计算一次 而不能考虑得过于周全</span><br>    <span class="hljs-comment"># 基础糖果数量</span><br>    baseVal = <span class="hljs-built_in">len</span>(ratings)<br>    <span class="hljs-comment"># 由于相邻的两个孩子有一个要求是评分更高的糖果更多</span><br>    left = [<span class="hljs-number">1</span>] * baseVal<br>    right = [<span class="hljs-number">1</span>] * baseVal<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(ratings)):<br>        <span class="hljs-keyword">if</span> ratings[i-<span class="hljs-number">1</span>] &lt; ratings[i]:<br>            left[i] = left[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ratings)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]:<br>            right[i] = right[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, baseVal):<br>        res += <span class="hljs-built_in">max</span>(right[i], left[i])<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li><li>常数级别遍历<br>![[Pasted image 20240323203335.png]]<br>![[Pasted image 20240323203347.png]]<br>需要注意的是，评分相同时，后面的那个孩子应该给1个糖果（因为题目中没有说评分一致时糖果也应该一致），同时增加序列长度的记忆功能，当升降序列长度相等时，应该为降序列再增加一个糖果<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">candy</span>(<span class="hljs-params">self, ratings: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 使用增长序列的方法来做</span><br>    <span class="hljs-comment"># 初始化一些变量</span><br>    length = <span class="hljs-built_in">len</span>(ratings)<br>    dec, inc, pre, res = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length):<br>        <span class="hljs-keyword">if</span> ratings[i] &gt;= ratings[i-<span class="hljs-number">1</span>]:<br>            dec = <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 说明在升序序列</span><br>            pre = pre + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ratings[i] != ratings[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>            res += pre<br>            <span class="hljs-comment"># 升序序列的长度</span><br>            inc = pre<br>        <span class="hljs-keyword">else</span>:<br>            dec += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dec == inc:<br>                dec += <span class="hljs-number">1</span><br>            res += dec<br>            pre = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li></ul><h3 id="1835-所有数对按位与结果的异或和"><a href="#1835-所有数对按位与结果的异或和" class="headerlink" title="1835. 所有数对按位与结果的异或和"></a><a href="https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/">1835. 所有数对按位与结果的异或和</a></h3><ul><li>优化后的结果（根据分配律进行优化）</li><li>a&amp;c ^b&amp;c &#x3D; (a^b) &amp; c<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 考虑优化算法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getXORSum</span>(<span class="hljs-params">self, arr1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], arr2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># a&amp;c ^ b&amp;c = (a^b) &amp; c</span><br>    <span class="hljs-comment"># 根据这个公式</span><br>    a1 = arr1[<span class="hljs-number">0</span>]<br>    a2 = arr2[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 注意边界条件,因为一个数与自己做异或的结果是0,所以一定要注意边界条件</span><br>    <span class="hljs-comment"># 0 位置的已经取出来了,所以需要从1开始</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr1)):<br>        a1 = a1 ^ arr1[i]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr2)):<br>        a2 = a2 ^ arr2[i]<br>    <span class="hljs-keyword">return</span> a1 &amp; a2<br></code></pre></td></tr></table></figure></li><li>一个看似正确但是超过内存限制的暴力算法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下面的算法会超过内存限制 gg</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getXORSum</span>(<span class="hljs-params">self, arr1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], arr2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 先写一个试试吧</span><br>    andSum = []<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(arr1)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(arr2)):<br>            andSum.append(arr1[i] &amp; arr2[j])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(andSum)&lt;=<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> andSum[<span class="hljs-number">0</span>]<br>    res = andSum[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(andSum)):<br>        res = res ^ andSum[i]<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li></ul><h3 id="1840-最高建筑高度"><a href="#1840-最高建筑高度" class="headerlink" title="1840. 最高建筑高度"></a><a href="https://leetcode.cn/problems/maximum-building-height/">1840. 最高建筑高度</a></h3><ul><li>视频讲解<a href="https://www.bilibili.com/video/BV1uQ4y1f7QH/?spm_id_from=333.337.search-card.all.click">LeetCode LeetCode 1840. Maximum Building Height | Weekly Contest 239</a><br>这个题搞了我半天，最主要的其实是最终高度的计算，视频里的点很关键，如果左右两边的限制高度不一样，则可以人为让他们一样，即让少的一个多爬x个，再直接求两个相同高度的限制中的最高高度。</li><li>如果两个高度一样<br>![[Pasted image 20240504231729.png]]</li><li>如果不一样呢，那就先让两个变得一样，再按上面的方法计算<br>![[Pasted image 20240504231816.png]]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最大建筑高度</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxBuilding</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, restrictions: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 补充额外限制条件</span><br>    restrictions.append([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>    restrictions.append([n, n-<span class="hljs-number">1</span>])<br>    <span class="hljs-comment"># 排序</span><br>    restrictions.sort()<br>    <span class="hljs-comment"># 遍历限制数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        <span class="hljs-comment"># 有如下限制</span><br>        <span class="hljs-comment"># 相邻两个高度差不能超过1</span><br>        <span class="hljs-comment"># 注意：</span><br>        <span class="hljs-comment"># restrictions[i][0] 表示地的编号</span><br>        <span class="hljs-comment"># restrictions[i][1] 表示地的限制高度</span><br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + (restrictions[i][<span class="hljs-number">0</span>] - restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(restrictions)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + (restrictions[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - restrictions[i][<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-comment"># 遍历得到最大高度</span><br>    maxHeight = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        id1, h1 = restrictions[i-<span class="hljs-number">1</span>]<br>        id2, h2 = restrictions[i]<br>        maxHeight = <span class="hljs-built_in">max</span>(maxHeight, (h2 + h1 + id2 - id1)//<span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 可以除2是因为从一个高度到另一个高度可以先上升后下降</span><br>        <span class="hljs-comment"># 来一个形象的例子</span><br>        <span class="hljs-comment">#  / \</span><br>        <span class="hljs-comment"># /   \</span><br>        <span class="hljs-comment">#      \</span><br>    <span class="hljs-keyword">return</span> maxHeight<br></code></pre></td></tr></table></figure></li><li>coze写的代码<br>补充说明图片（5.4）<br>![[Pasted image 20240504231444.png]]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxBuilding</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, restrictions: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题不会做啊</span><br>    <span class="hljs-comment"># 只能看题解了</span><br><br>    <span class="hljs-comment"># 首先补充约束条件</span><br>    <span class="hljs-comment"># 第一块地不能修建筑</span><br>    restrictions.append([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># 对建筑进行排序</span><br>    restrictions.sort()<br>    <span class="hljs-comment"># 最后一块地的限制建筑高度(实际没有这个限制,主要是给n-1号用的)</span><br>    restrictions.append([n, n-<span class="hljs-number">1</span>])<br><br>    <span class="hljs-comment"># 从左往右遍历,应用限制</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        <span class="hljs-comment"># 设置restrictions[i][0]块地的限制高度</span><br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] +<br>            restrictions[i][<span class="hljs-number">0</span>]-restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>        )<br>    <span class="hljs-comment"># 从右往左遍历,应用限制(为什么第二个参数是-1？因为0是最后一个需要遍历的值，所以0的下一个就是-1)</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(restrictions)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] +<br>            restrictions[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - restrictions[i][<span class="hljs-number">0</span>]<br>        )<br><br>    <span class="hljs-comment"># 在满足所有限制条件下找最高建筑</span><br>    max_h = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        id1, h1 = restrictions[i - <span class="hljs-number">1</span>]<br>        id2, h2 = restrictions[i]<br>        max_h = <span class="hljs-built_in">max</span>(max_h, (h2 - h1 + id2 - id1) // <span class="hljs-number">2</span> + h1)<br>    <span class="hljs-keyword">return</span> max_h<br></code></pre></td></tr></table></figure></li><li>复习写的代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxBuilding</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, restrictions: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 首先添加虚拟建筑</span><br>    restrictions.append([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>    restrictions.append([n, n-<span class="hljs-number">1</span>])<br>    restrictions.sort()<br><br>    <span class="hljs-comment"># 从左到右遍历</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+(restrictions[i][<span class="hljs-number">0</span>]-restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-comment"># 从右往左遍历</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(restrictions)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+(restrictions[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-restrictions[i][<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-comment"># 找到最大建筑</span><br>    maxHeight = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions), <span class="hljs-number">1</span>):<br>        index1, height1 = restrictions[i-<span class="hljs-number">1</span>]<br>        index2, height2 = restrictions[i]<br>        maxHeight = <span class="hljs-built_in">max</span>(<br>            maxHeight, ((index2-index1)+(height2-height1))//<span class="hljs-number">2</span>+height1)<br>    <span class="hljs-keyword">return</span> maxHeight<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="670. 最大交换"></a><a href="https://leetcode.cn/problems/maximum-swap/">670. 最大交换</a></h3><ul><li>5.4复习<br>![[Pasted image 20240504230333.png]]</li><li>3.23复习<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 3/23最大交换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumSwap</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 目标：找到x右侧比x大的数</span><br>    <span class="hljs-comment"># 忘了昨天怎么做的了</span><br>    <span class="hljs-comment"># 盲猜从右向左遍历</span><br>    <span class="hljs-comment"># 首先转换int为数组</span><br>    numList = [<span class="hljs-built_in">int</span>(digit) <span class="hljs-keyword">for</span> digit <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(num)]<br>    <span class="hljs-comment"># 记录每个数字最后出现的位置</span><br>    lastSeen = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numList)&#125;<br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numList):<br>        <span class="hljs-comment"># 从9-(x+1)的范围内找数,看看是不是在右边,从大往小找</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>, x, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> lastSeen.get(j, -<span class="hljs-number">1</span>) &gt; i:<br>                <span class="hljs-comment"># 说明找到了</span><br>                <span class="hljs-comment"># 交换</span><br>                numList[i], numList[lastSeen.get(<br>                    j)] = numList[lastSeen.get(j)], numList[i]<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, numList)))<br>    <span class="hljs-keyword">return</span> num<br></code></pre></td></tr></table></figure></li><li>一种朴素且错误的思维<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个版本有问题</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumSwap</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 一个朴素的想法是把最大的值和第一位交换，得到的总是较大的</span><br>    <span class="hljs-comment"># 遍历一次数组</span><br>    <span class="hljs-comment"># 把num转换成字符串</span><br>    listNum = self.intToList(num)<br>    maxIndex = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(listNum)):<br>        maxIndex = maxIndex <span class="hljs-keyword">if</span> listNum[maxIndex] &gt; listNum[i] <span class="hljs-keyword">else</span> i<br>    <span class="hljs-comment"># swap</span><br>    listNum[<span class="hljs-number">0</span>], listNum[maxIndex] = listNum[maxIndex], listNum[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> self.listToInt(listNum)<br><br><span class="hljs-comment"># 想法果然还是太过于朴素了，因为完全没有考虑到最大的值已经在最高位的情况</span><br><span class="hljs-comment"># 那应该怎么做？把第二大的放到第二位？也不可行，需要考虑的有点多</span><br><span class="hljs-comment"># 比如98368这个数字</span><br><span class="hljs-comment"># 第二大的是8 但是8已经在第2位了</span><br><span class="hljs-comment"># 继续下去？</span><br><span class="hljs-comment"># 复杂度直接进化到O(N^2)了</span><br></code></pre></td></tr></table></figure></li><li>我愿称coze为yyds<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 最大交换</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intToList</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>:<br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">int</span>(digit) <span class="hljs-keyword">for</span> digit <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(n)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">listToInt</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, nums)))<br>    <span class="hljs-comment"># coze协作编程代码</span><br>    <span class="hljs-comment"># 方法很巧妙</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumSwap</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 把num转换成数组</span><br>        numList = self.intToList(num)<br>        <span class="hljs-comment"># 记录每个数字最后出现的位置(用了一个字典，如果有重复值，则会更新位置，由于是从前到后遍历，所以可以保证是最后出现的)</span><br>        last = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numList)&#125;<br>        <span class="hljs-comment"># 从左到右遍历数组</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numList):<br>            <span class="hljs-comment"># 从9到x + 1查找可能的最大值（倒序查找，找到x右侧比x大的数）</span><br>            <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>, x, -<span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># 如果找到更大值，并且该更大值的索引在当前索引的右侧</span><br>                <span class="hljs-keyword">if</span> last.get(d, -<span class="hljs-number">1</span>) &gt; i:<br>                    <span class="hljs-comment"># 交换这两个值</span><br>                    numList[i], numList[last[d]] = numList[last[d]], numList[i]<br>                    <span class="hljs-comment"># 由于只允许交换一次，直接返回结果</span><br>                    <span class="hljs-keyword">return</span> self.listToInt(numList)<br>        <span class="hljs-comment"># 如果没有交换发生，直接返回原数</span><br>        <span class="hljs-keyword">return</span> num<br></code></pre></td></tr></table></figure></li></ul><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><ul><li>错误的双指针法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最大子数组和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 看到题目想到的就是滑动窗口</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 初始化两个指针</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    maxVal = -sys.maxsize - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (right &lt; <span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-comment"># 当前窗口和</span><br>        curVal = self.subArraySum(nums, left, right)<br>        maxVal = maxVal <span class="hljs-keyword">if</span> maxVal &gt;= curVal <span class="hljs-keyword">else</span> curVal<br>        <span class="hljs-comment"># 移动指针</span><br>        <span class="hljs-comment"># 做到这里 感觉好像找不到移动指针的方法了...</span><br>        <span class="hljs-comment"># 但是通过思考发现 好像可以用动态规划</span><br>        right += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li><li>正确的动态规划法（卡登算法？）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最大子数组和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 使用动态规划来解决这个问题</span><br>    <span class="hljs-comment"># 首先初始化dp数组</span><br>    dp = [nums[<span class="hljs-number">0</span>]] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure></li></ul><h5 id="⚠️思考为什么最后一个值不是最大值"><a href="#⚠️思考为什么最后一个值不是最大值" class="headerlink" title="⚠️思考为什么最后一个值不是最大值?"></a>⚠️思考为什么最后一个值不是最大值?</h5><p>因为dp[i]的值是以nums[i]结尾的子数组的最大和，所以并不是全局最大和</p><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><p>很简单，注意边界条件需要包含等于，否则只有一个元素的情况下会直接返回-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        lens = <span class="hljs-built_in">len</span>(nums)<br>        l, r = <span class="hljs-number">0</span>, lens - <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 注意边界条件</span><br>        <span class="hljs-keyword">while</span> (l &lt;= r):<br>            m = (l + r) &gt;&gt; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> nums[m] == target:<br>                <span class="hljs-keyword">return</span> m<br>            <span class="hljs-keyword">elif</span> nums[m] &lt; target:<br>                l = m + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                r = m - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 看到这个题的第一眼就是双指针</span><br><br>        slow, fast = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-comment"># slow指针用来指示目标数组的位置</span><br>        <span class="hljs-comment"># fast指正用来遍历数组，找到目标元素</span><br>        <span class="hljs-keyword">while</span>(fast &lt; l):<br>            <span class="hljs-comment"># 找到了目标元素</span><br>            <span class="hljs-keyword">if</span> nums[fast]==val:<br>                <span class="hljs-comment"># slow指针停在原地，等待找到下一个非目标元素替换掉</span><br>                fast += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 如果不是目标元素</span><br>            <span class="hljs-keyword">else</span>:<br>                nums[slow] = nums[fast]<br>                fast += <span class="hljs-number">1</span><br>                slow += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> slow<br>        <br></code></pre></td></tr></table></figure><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 由于数组是有序的，所有可以考虑使用双指针法，从左右两端分别遍历</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        left, right = <span class="hljs-number">0</span>, l - <span class="hljs-number">1</span><br>        result = [<span class="hljs-number">0</span>] * l<br>        index = l - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right):<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(nums[left]) &gt;= <span class="hljs-built_in">abs</span>(nums[right])):<br>                result[index] = (nums[left] * nums[left])<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result[index] = (nums[right] * nums[right])<br>                right -= <span class="hljs-number">1</span><br>            index -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br>        <br></code></pre></td></tr></table></figure><h3 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><a href="https://leetcode.cn/problems/third-maximum-number/">414. 第三大的数</a></h3><ul><li>一种错误的解法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 第三大的数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">thirdMax</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 最简单的方法就是排序之后选第3大的</span><br>        <span class="hljs-comment"># 但是进一步思考，如果只需要第3大的，还需要对所有数组排序吗</span><br>        <span class="hljs-comment"># 看上去是不需要的，因此这里使用冒泡排序找到第三大的即可</span><br>        <span class="hljs-comment"># 时间复杂度O(3N)</span><br>        length = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, length <span class="hljs-keyword">if</span> length &lt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, length):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                    <span class="hljs-comment"># swap</span><br>                    nums[i], nums[j] = nums[j], nums[i]<br>        <span class="hljs-built_in">print</span>(nums)<br>        <span class="hljs-comment"># 事实证明这样的解法是有bug的，因为nums中可能有重复的值，所以还需要进行去重操作</span><br>        <span class="hljs-comment"># 一种想到的思路是维护一个集合，用来去重，但是不如一开始就用集合，所以这样是脱裤子放屁</span><br>        <span class="hljs-keyword">return</span> nums[-<span class="hljs-number">3</span>] <span class="hljs-keyword">if</span> length &gt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> nums[-<span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure></li><li>正确的高效解法：运用集合去重（注意事项：边界条件）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">thirdMax</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>  <span class="hljs-comment"># 维护一个集合，使得集合中只有3个数，并且超出时删除最小的</span><br>  s = <span class="hljs-built_in">set</span>()<br>  <span class="hljs-comment"># 遍历数组</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)):<br>    s.add(nums[i])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">3</span>:<br>      <span class="hljs-comment"># 删除集合中最小的值</span><br>      minValue = <span class="hljs-built_in">min</span>(s)<br>      s.remove(minValue)<br>    <span class="hljs-built_in">print</span>(s)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(s) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &gt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">max</span>(s)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mit 6.s081 lab1</title>
    <link href="/2024/02/21/mit-6-s081-lab1/"/>
    <url>/2024/02/21/mit-6-s081-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="mit-6-s081-lab1"><a href="#mit-6-s081-lab1" class="headerlink" title="mit 6.s081 lab1"></a>mit 6.s081 lab1</h1><h2 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep(easy)"></a>sleep(easy)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-comment">// If the user forgets to pass an argument, sleep should print an error message.</span><br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>  &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;usage: sleep &lt;number&gt;\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// The command-line argument is passed as a string; you can convert it to an integer using atoi (see user/ulib.c).</span><br>  <span class="hljs-type">int</span> sleepTime = atoi(argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-comment">// Use the system call sleep.</span><br>  sleep(sleepTime);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong(easy)"></a>pingpong(easy)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-comment">// the byte to be sent</span><br>  <span class="hljs-type">char</span> *ping = <span class="hljs-string">&quot;p&quot;</span>;<br>  <span class="hljs-comment">// pipe file descriptors</span><br>  <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>  <span class="hljs-comment">// create pipe</span><br>  pipe(fd);<br>  <span class="hljs-comment">// fd[0] for read</span><br>  <span class="hljs-comment">// fd[1] for write</span><br>  <span class="hljs-comment">// create child process</span><br>  <span class="hljs-type">int</span> cpid = fork();<br>  <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-comment">// child process</span><br>    <span class="hljs-comment">// read a byte from the pipe</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (read(fd[<span class="hljs-number">0</span>], buf, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>    &#123;<br>      <span class="hljs-comment">// the child should print &quot;&lt;pid&gt;: received ping&quot;</span><br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;received a byte from the pipe: %s\n&quot;</span>, buf);<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br>      close(fd[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// write the byte on the pipe to the parent</span><br>    write(fd[<span class="hljs-number">1</span>], buf, <span class="hljs-number">1</span>);<br>    close(fd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// exit</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cpid &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-comment">// parent process</span><br>    <span class="hljs-comment">// The parent should send a byte to the child</span><br>    write(fd[<span class="hljs-number">1</span>], ping, <span class="hljs-number">1</span>);<br>    close(fd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// wait for the child to finish</span><br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// read the byte from the child</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (read(fd[<span class="hljs-number">0</span>], buf, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>    &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;received a byte from the pipe: %s\n&quot;</span>, buf);<br>      <span class="hljs-comment">// print &quot;&lt;pid&gt;: received pong&quot;</span><br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br>      close(fd[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// exit</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="primes-hard"><a href="#primes-hard" class="headerlink" title="primes(hard)"></a>primes(hard)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>])</span><br>&#123;<br>  <span class="hljs-type">int</span> receivedNum;<br>  <span class="hljs-type">int</span> currentPrime;<br><br>  close(fd[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">if</span> (read(fd[<span class="hljs-number">0</span>], &amp;currentPrime, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>)<br>  &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read error\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// the first number received must be a prime number</span><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;prime %d\n&quot;</span>, currentPrime);<br><br>  <span class="hljs-comment">// judge whether the next is not exist</span><br>  <span class="hljs-keyword">if</span> (read(fd[<span class="hljs-number">0</span>], &amp;receivedNum, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<br>  &#123;<br>    close(fd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// !!!!!!!!! SHOULD CREATE NEW PIPE !!!!!!!!!</span><br>  <span class="hljs-type">int</span> newfd[<span class="hljs-number">2</span>];<br>  pipe(newfd);<br><br>  <span class="hljs-comment">// fork a child process</span><br>  <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)<br>  &#123;<br>    func(newfd);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    close(newfd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// eliminate all the numbers that are multiples of the prime number</span><br>    <span class="hljs-comment">// first should process the &quot;receivedNum&quot; which recevied just now</span><br>    <span class="hljs-keyword">if</span> (receivedNum % currentPrime != <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (write(newfd[<span class="hljs-number">1</span>], &amp;receivedNum, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>)<br>      &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// read old pipe and write new pipe</span><br>    <span class="hljs-keyword">while</span> (read(fd[<span class="hljs-number">0</span>], &amp;receivedNum, <span class="hljs-number">4</span>) == <span class="hljs-number">4</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (receivedNum % currentPrime != <span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (write(newfd[<span class="hljs-number">1</span>], &amp;receivedNum, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>)<br>        &#123;<br>          <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// no need for every process to close the pipe, just close the pipe in the end</span><br>    close(fd[<span class="hljs-number">0</span>]);<br>    close(newfd[<span class="hljs-number">1</span>]);<br>    wait(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-comment">// create a pipe</span><br>  <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>  pipe(fd);<br><br>  <span class="hljs-comment">// use fork create a child process</span><br>  <span class="hljs-type">int</span> cpid = fork();<br><br>  <span class="hljs-keyword">if</span> (cpid == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-comment">// child process</span><br>    <span class="hljs-comment">// call func</span><br>    func(fd);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cpid &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-comment">// parent process</span><br>    close(fd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// pass [2...35] to the child process</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (write(fd[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>)<br>      &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    close(fd[<span class="hljs-number">1</span>]);<br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="find-just-follow-hints"><a href="#find-just-follow-hints" class="headerlink" title="find(just follow hints)"></a>find(just follow hints)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fmtname</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[DIRSIZ + <span class="hljs-number">1</span>];<br>  <span class="hljs-type">char</span> *p;<br><br>  <span class="hljs-comment">// Find first character after last slash.</span><br>  <span class="hljs-keyword">for</span> (p = path + <span class="hljs-built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="hljs-string">&#x27;/&#x27;</span>; p--)<br>    ;<br>  p++;<br><br>  <span class="hljs-comment">// Return blank-padded name.</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(p) &gt;= DIRSIZ)<br>    <span class="hljs-keyword">return</span> p;<br>  memmove(buf, p, <span class="hljs-built_in">strlen</span>(p));<br>  <span class="hljs-built_in">memset</span>(buf + <span class="hljs-built_in">strlen</span>(p), <span class="hljs-string">&#x27; &#x27;</span>, DIRSIZ - <span class="hljs-built_in">strlen</span>(p));<br>  <span class="hljs-keyword">return</span> buf;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">findFunc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-comment">// modify from ls.c</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>  <span class="hljs-keyword">if</span> ((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>    close(fd);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">switch</span> (st.type)<br>  &#123;<br>  <span class="hljs-keyword">case</span> T_FILE:<br>    <span class="hljs-comment">// if the raw path is a file, it goes wrong</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: find dir file\n&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-keyword">case</span> T_DIR:<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">strcpy</span>(buf, path);<br>    p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<br>    &#123;<br>      <span class="hljs-comment">// ignore the . and ..</span><br>      <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">continue</span>;<br>      memmove(p, de.name, DIRSIZ);<br>      p[DIRSIZ] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-comment">// if the path is dir</span><br>      <span class="hljs-keyword">if</span> (st.type == T_DIR)<br>      &#123;<br>        <span class="hljs-comment">// recursive call</span><br>        findFunc(buf, name);<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.type == T_FILE)<br>      &#123;<br>        <span class="hljs-comment">// if the path is file</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, name) == <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>  &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;usage: find &lt;path&gt; &lt;name&gt;\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path = argv[<span class="hljs-number">1</span>];<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name = argv[<span class="hljs-number">2</span>];<br><br>  findFunc(path, name);<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="xargs-not-easy"><a href="#xargs-not-easy" class="headerlink" title="xargs(not easy)"></a>xargs(not easy)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readLine</span><span class="hljs-params">(<span class="hljs-type">char</span> **argvlist, <span class="hljs-type">int</span> i)</span><br>&#123;<br>  <span class="hljs-type">int</span> maxBufSize = <span class="hljs-number">1024</span>;<br>  <span class="hljs-type">char</span> buf[maxBufSize];<br>  <span class="hljs-type">int</span> bufSize = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// read one line</span><br>  <span class="hljs-comment">// each loop read one char</span><br>  <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, buf + bufSize, <span class="hljs-number">1</span>))<br>  &#123;<br>    <span class="hljs-keyword">if</span> (buf[bufSize] == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    &#123;<br>      buf[bufSize] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    bufSize++;<br>    <span class="hljs-keyword">if</span> (bufSize &gt;= maxBufSize)<br>    &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;xargs: input too long\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (bufSize == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// processing space, add to argvlist</span><br>  <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (idx &lt; bufSize)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; MAXARG)<br>    &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;xargs: too many arguments\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// find the first non-space char</span><br>    <span class="hljs-keyword">while</span> ((idx &lt; bufSize) &amp;&amp; (buf[idx] == <span class="hljs-string">&#x27; &#x27;</span>))<br>    &#123;<br>      idx++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> argsStart = idx;<br>    <span class="hljs-comment">// find the first space char</span><br>    <span class="hljs-keyword">while</span> ((idx &lt; bufSize) &amp;&amp; (buf[idx] != <span class="hljs-string">&#x27; &#x27;</span>))<br>    &#123;<br>      idx++;<br>    &#125;<br>    <span class="hljs-type">int</span> argsEnd = idx;<br>    <span class="hljs-comment">// add args to argvlist</span><br>    argvlist[i] = <span class="hljs-built_in">malloc</span>(argsEnd - argsStart + <span class="hljs-number">1</span>);<br>    buf[idx++] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">strcpy</span>(argvlist[i], buf + argsStart);<br>    i++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-comment">// wait the process before | finish</span><br>  sleep(<span class="hljs-number">3</span>);<br>  <span class="hljs-comment">// argvlist</span><br>  <span class="hljs-type">char</span> *argvlist[MAXARG];<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>  &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;usage: xargs command\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-comment">// add array argv to argvlist</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)<br>    &#123;<br>      <span class="hljs-comment">// manipulate the argvlist</span><br>      argvlist[i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(argv[i]) + <span class="hljs-number">1</span>);<br>      <span class="hljs-built_in">strcpy</span>(argvlist[i - <span class="hljs-number">1</span>], argv[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// read the input from the standard input</span><br>  <span class="hljs-type">int</span> end;<br>  <span class="hljs-keyword">while</span> ((end = readLine(argvlist, argc - <span class="hljs-number">1</span>)) != <span class="hljs-number">-1</span>)<br>  &#123;<br>    argvlist[end] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)<br>    &#123;<br>      exec(argvlist[<span class="hljs-number">0</span>], argvlist);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      wait(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.s081</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Learning Experience</title>
    <link href="/2023/11/13/Java-Learning-Experience/"/>
    <url>/2023/11/13/Java-Learning-Experience/</url>
    
    <content type="html"><![CDATA[<h2 id="学习进度"><a href="#学习进度" class="headerlink" title="学习进度"></a>学习进度</h2><ul><li>参考教程：Spring 核心教程 已完结（IDEA 2023最新版）4K蓝光画质 基于Spring6的全新重制版本 起立到起飞（<a href="https://www.bilibili.com/video/BV1Kv4y1x7is%EF%BC%89">https://www.bilibili.com/video/BV1Kv4y1x7is）</a></li></ul><table><thead><tr><th>序号</th><th>视频标题</th><th>是否学习</th><th>学后感</th></tr></thead><tbody><tr><td>1</td><td>Spring基础：走进Spring框架</td><td>✅</td><td>发现自己还有很多没有学懂，但是还有java基础，所以还来得及补习</td></tr><tr><td>2</td><td>Spring基础：IoC理论基础</td><td>✅</td><td>IoC控制反转，IoC容器用来管理Bean</td></tr><tr><td>3</td><td>Spring基础：第一个Spring项目</td><td>✅</td><td>使用idea创建了一个Spring项目</td></tr><tr><td>4</td><td>Spring基础：Bean注册与配置</td><td>✅</td><td>使用xml方式管理bean</td></tr><tr><td>5</td><td>Spring基础：依赖注入</td><td>✅</td><td></td></tr><tr><td>6</td><td>Spring基础：自动装配</td><td>✅</td><td>可以不用手动指定，而是通过ByType或者ByName进行自动装配</td></tr><tr><td>7</td><td>Spring基础：生命周期与继承</td><td>✅</td><td>介绍两个方法，init和destroy</td></tr><tr><td>8</td><td>Spring基础：工厂模式与工厂Bean</td><td>✅</td><td>关于工厂模式</td></tr><tr><td>9</td><td>Spring基础：使用注解开发</td><td>✅</td><td>走神了</td></tr><tr><td>⭐</td><td>笔记整理回顾</td><td></td><td></td></tr><tr><td>⭐</td><td>编程实践</td><td></td><td></td></tr><tr><td>10</td><td>选学：Aware系列接口</td><td></td><td></td></tr><tr><td>11</td><td>选学：任务调度</td><td></td><td></td></tr><tr><td>12</td><td>选学：监听器</td><td></td><td></td></tr><tr><td>13</td><td>SpEL入门：外部属性注入</td><td></td><td></td></tr><tr><td>14</td><td>SpEL入门：简单使用</td><td></td><td></td></tr><tr><td>15</td><td>SpEL入门：集合类相关操作</td><td></td><td></td></tr><tr><td>16</td><td>Spring基础：XML配置AOP</td><td></td><td></td></tr><tr><td>17</td><td>Spring基础：接口实现AOP</td><td></td><td></td></tr><tr><td>18</td><td>Spring基础：注解实现AOP</td><td></td><td></td></tr><tr><td>19</td><td>Mybatis整合：了解数据源</td><td></td><td></td></tr><tr><td>20</td><td>选学：两种数据源实现原理解读</td><td></td><td></td></tr><tr><td>21</td><td>Mybatis整合：整合流程与实现</td><td></td><td></td></tr><tr><td>22</td><td>Mybatis整合：HikariCP连接池</td><td></td><td></td></tr><tr><td>23</td><td>Mybatis整合：事务管理</td><td></td><td></td></tr><tr><td>24</td><td>Mybatis整合：Spring事务</td><td></td><td></td></tr><tr><td>25</td><td>JUnit整合：基本使用</td><td></td><td></td></tr><tr><td>26</td><td>原理探究：Bean的定义与生成</td><td></td><td></td></tr><tr><td>27</td><td>原理探究：单例Bean创建与循环依赖</td><td></td><td></td></tr><tr><td>28</td><td>原理探究：AOP与后置处理器</td><td></td><td></td></tr><tr><td>29</td><td>原理探究：应用程序上下文</td><td></td><td></td></tr><tr><td>30</td><td>原理探究：Mybatis整合原理</td><td></td><td></td></tr></tbody></table><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h3><ul><li>什么是IoC<br>IoC全名<strong>控制反转（Inversion of Control）：</strong>把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</li><li>为什么需要使用IoC将对象交给IoC容器进行管理，比如当我们需要一个接口的实现时，由它根据配置文件来决定到底给我们哪一个实现类，这样，我们就可以不用再关心我们要去使用哪一个实现类了，我们只需要关心，给到我的一定是一个可以正常使用的实现类。</li><li>创建一个Spring6项目需要干的事情<br>打开idea -&gt; 新建maven项目 -&gt; 引入spring框架 -&gt; 在resource目录下新建application.xml配置文件（使用xml开发）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>什么是Bean</li><li>什么是依赖注入</li><li>自动装配</li><li>注解开发</li><li>生命周期</li><li>bean继承</li><li>工厂模式与bean</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>总览--模型量化</title>
    <link href="/2023/10/18/Model-quantization-survey/"/>
    <url>/2023/10/18/Model-quantization-survey/</url>
    
    <content type="html"><![CDATA[<h2 id="博客文章"><a href="#博客文章" class="headerlink" title="博客文章"></a>博客文章</h2><p>Adabin</p><h2 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h2><table><thead><tr><th>论文</th><th>年份</th><th>会议&#x2F;期刊</th><th>代码链接</th><th>备注</th><th>笔记</th></tr></thead><tbody><tr><td>Adabin: Improving Binary Neural Networks with Adaptive Binary Sets</td><td>2022</td><td>ECCV</td><td></td><td></td><td></td></tr><tr><td>IR-Net: Forward and Backward Information Retention for Accurate Binary Neural Networks</td><td>2020</td><td>CVPR</td><td><a href="https://github.com/htqin/IR-Net">https://github.com/htqin/IR-Net</a></td><td>精读，开启二值化学习之路</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="SOTA模型性能"><a href="#SOTA模型性能" class="headerlink" title="SOTA模型性能"></a>SOTA模型性能</h2><h3 id="CIFAR10"><a href="#CIFAR10" class="headerlink" title="CIFAR10"></a>CIFAR10</h3><h3 id="ImageNet-1K"><a href="#ImageNet-1K" class="headerlink" title="ImageNet-1K"></a>ImageNet-1K</h3><h3 id="CIFAR100"><a href="#CIFAR100" class="headerlink" title="CIFAR100"></a>CIFAR100</h3>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>模型量化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组会笔记</title>
    <link href="/2023/10/15/MeetingNote/"/>
    <url>/2023/10/15/MeetingNote/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="74ea512e2b275aef5897e60b693fe32d7da4b8f6eb9ed708eaed53180acc1a7a">ffb0b1dc140d343e3196a6699eef89033c64c1198e263c66efe345127caf36b87ee1eb0c9dbfd393a601d64156614d835808c0c7d231363ee8133900471cce188973dd5e628f96d93a080a5d4fabee52c5971af461d00767a025d9699dfb933f321e36c50f3deeb685569c5f3d74b6db353ef5ef93a6f02dd496286093330cf60e1f0cccf2f83e3e76697467ba12536ada2eaf2499f7a2345a6238e640f13096491d723b7cda5a8ab8c91c37f7d742cef0652873277b3d378ff39494351886f3ef929083ca84b991bae38a8a3182c3901fff3f512ada684e3992acbe2f2740c1636e552578bddb0c8eb4e610d5648db1ce4a1728af1e43e6b6b3c4aeb5d39def70ef2b328d6b466f805f26e8fe168217707e2e2e5c228610170ee34a3ae7bb9899e43030ef30953cf75e398994bdff50426826c6343c91262923300180a16da188384b30be3119cf39642f9e92e4711a9c55c29b523eede15309d9b6f8625b8ec1eb70dc0c2173cb12fd46bc40e285eaa5865bb7966abab111096ad71206ba3ff9f68138b31e87f4fe96d7a7ffb2adf79d8d366e76ba24258d7f17ca4313eba98e9b28cb3eef327138bdb4198893f9fc2459d2efe8ba8fc092451e3edeeb0ddbbe7fcb443e8b74eac7c81ba478d1348f86545b97cbcdf665c8c699a1f20143a5d6ed8245aefe0d1dba91e4f78a28d39124d2d220ac959342c48e8f5de3d2e3c4f1c15aadfdc7a52eb74ed415ac3d22433459990270a8d724fd7daf263b5640423020195a2632f891de046bf0a8932f043fa6f8384fb557e3b69f38942adfb972fc57f7609fb687967f39bc46bbbce2e8f08d8e007e6613eeb43102e0664d35fdc1309e9334fd5df4e2aca6c98cc906d4447fc85013f492a9fa989400e6070112dc35533cb04524f38637540a76dff334</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>加密</tag>
      
      <tag>笔记</tag>
      
      <tag>组会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读---Forward and Backward Information Retention for Accurate Binary Neural Networks</title>
    <link href="/2023/10/07/Paper-IR-net/"/>
    <url>/2023/10/07/Paper-IR-net/</url>
    
    <content type="html"><![CDATA[<h2 id="论文原文及笔记"><a href="#论文原文及笔记" class="headerlink" title="论文原文及笔记"></a>论文原文及笔记</h2><div class="row">    <embed src="/pdf/ForwardandBackwardInformationRetentionforAcc.pdf" width="100%" height="550" type="application/pdf"></div><p>就不单独写笔记了，笔记都在PDF上哈哈哈</p><h2 id="PPT分享"><a href="#PPT分享" class="headerlink" title="PPT分享"></a>PPT分享</h2><div class="row">    <embed src="/pdf/meetingPPT.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Graduate from SWJTU</title>
    <link href="/2023/10/06/Graduate-from-SWJTU/"/>
    <url>/2023/10/06/Graduate-from-SWJTU/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>资源---西南交通大学《机器学习实验》课程设计</title>
    <link href="/2023/10/06/ML-CourseDesign/"/>
    <url>/2023/10/06/ML-CourseDesign/</url>
    
    <content type="html"><![CDATA[<h2 id="西南交通大学《机器学习实验》课程设计"><a href="#西南交通大学《机器学习实验》课程设计" class="headerlink" title="西南交通大学《机器学习实验》课程设计"></a>西南交通大学《机器学习实验》课程设计</h2><h3 id="仅供参考，请勿抄袭"><a href="#仅供参考，请勿抄袭" class="headerlink" title="仅供参考，请勿抄袭 "></a><span style="color:red">仅供参考，请勿抄袭 </span></h3><h3 id="回过头来看以前完成的报告，观感上还是很赏心悦目，对得起自己的努力😁"><a href="#回过头来看以前完成的报告，观感上还是很赏心悦目，对得起自己的努力😁" class="headerlink" title="回过头来看以前完成的报告，观感上还是很赏心悦目，对得起自己的努力😁"></a>回过头来看以前完成的报告，观感上还是很赏心悦目，对得起自己的努力😁</h3><div class="row">    <embed src="/pdf/test.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>报告</tag>
      
      <tag>课程设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo加密功能</title>
    <link href="/2023/10/01/Crypto-test/"/>
    <url>/2023/10/01/Crypto-test/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a8d01c49ceae15be7cfdb01c20b7a2749dc5f6e2c9b78dadd430c1571f36b760">f4cc23558ba95030556638b09840cfb704f3786c88b878ba14a45b3d167bfac4a3758146f34aff27dc9729ff3110e5f564ba3564760a046b47e896b73a0aea1063cc682c6c4f64c5c3a047085c27210c5b4608cc3365d4a220e00e9435a5950c698183c9973f3ee48df281a265d8700f70be93009dfeca168ae54e2fda49111832cf553c3f26e494bb40ab375ac2ee430a34e78a2d7165e53bc72c644346ade53bfc8dfd9f23336329766248f2f0b556fb636ee32f4d1410e9fa556bf61ba0b567a461808dbb89f45d3c19d24c6d0db491f7429c0eaa544d1c0d1c9dc6d050e10fd26272cc2f9200323773c5f662c54063d651fdc9215b7d0048e43ad5f6416fbb39b304705c021cb5297b717e25e419ed2daf87151723d110b907abd6a1fcce2da71d900673e52080c402f6831c1b7d036f679bf2680062d717c1b67bbc81515ad57a7ec1142e92462efe576799fa8e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这篇博客需要密码才能看哦～（悄悄告诉你密码是smile）😊</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>测试博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加密</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记---杭州之旅</title>
    <link href="/2023/09/28/HangZhou-Journal/"/>
    <url>/2023/09/28/HangZhou-Journal/</url>
    
    <content type="html"><![CDATA[<h2 id="抵达前"><a href="#抵达前" class="headerlink" title="抵达前"></a>抵达前</h2><p>此次前去杭州，是为了参加CCCC-移动应用创新赛的决赛，关于这个比赛，是由苹果和浙江大学共同举办的一场关于IOS应用开发的比赛。此处需要感谢我的队友提出富有创意和社会责任感的IDEA，使得我能够前往杭州参加决赛（本人主要负责IDEA的具体实现及开发工作）。此次参赛其实心态很放松，本着学习他人优秀作品以及旅游的态度去的，也没有想过能够拿到比较高的奖项（拿到保底就是胜利）。不过最后的结果却是令人惊喜的，这都是后话了。</p><p>前往杭州，我选择了乘坐天府机场的航班，这也是第一次到传说中“到哪里都是两小时，包括成都市区”的天府机场“赶飞机”，为了省钱，选了红眼航班（凌晨到达）。从电子科大清水河校区到天府机场的确是一段较远的行程，所以也提前预留了机动时间。</p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>到达杭州其实才凌晨，本着省钱的原则，在机场及其不舒适的椅子上“睡”了一晚上，其实感觉称不上睡……早上地铁开始运行后，就朝着目的地—浙江大学紫金港校区出发了。第一站，先去找已经到达杭州的队友小伙伴会合，答辩前最后一次调试代码，然后在他的酒店房间里面呼呼大睡。等到主办方的报道时间后，一起前往了主办方提供的酒店：浙大圆正启真水晶酒店进行报道。不得不说，还是集训营期间在上海的酒店更好一点（世纪大道旁边的万怡酒店，之后会补充介绍集训营），不过和上次一样的是，也配备了浴缸，可以泡澡了，美滋滋。</p><p>行程安排比较紧凑，上午报道，下午就开始进行决赛的评审了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
      <tag>生活记录</tag>
      
      <tag>移动应用创新赛</tag>
      
      <tag>比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
