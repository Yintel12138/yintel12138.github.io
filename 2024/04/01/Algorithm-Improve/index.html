

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Y.png">
  <link rel="icon" href="/img/Y.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#1f31448f">
  <meta name="author" content="Yintel">
  <meta name="keywords" content="life study technology coding">
  
    <meta name="description" content="写在前面：督促自己学习，顺便记录题解  更新记录 5&#x2F;19 更新211. 添加与搜索单词 - 数据结构设计、52. N 皇后 II、918. 环形子数组的最大和、97. 交错字符串（昨天尸体不舒服，所以没做，哈哈哈给自己找了个借口，不过今天补上） 5&#x2F;17 更新221. 最大正方形、289. 生命游戏 5&#x2F;16 更新230. 二叉搜索树中第K小的元素、530. 二叉">
<meta property="og:type" content="article">
<meta property="og:title" content="算法能力提升计划 Algorithm Capability Enhancement Program">
<meta property="og:url" content="https://yintel12138.github.io/2024/04/01/Algorithm-Improve/index.html">
<meta property="og:site_name" content="Yintel&#39;s Blog">
<meta property="og:description" content="写在前面：督促自己学习，顺便记录题解  更新记录 5&#x2F;19 更新211. 添加与搜索单词 - 数据结构设计、52. N 皇后 II、918. 环形子数组的最大和、97. 交错字符串（昨天尸体不舒服，所以没做，哈哈哈给自己找了个借口，不过今天补上） 5&#x2F;17 更新221. 最大正方形、289. 生命游戏 5&#x2F;16 更新230. 二叉搜索树中第K小的元素、530. 二叉">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-01T02:21:04.000Z">
<meta property="article:modified_time" content="2024-05-19T12:07:41.826Z">
<meta property="article:author" content="Yintel">
<meta property="article:tag" content="算法学习">
<meta property="article:tag" content="计划">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>算法能力提升计划 Algorithm Capability Enhancement Program - Yintel&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yintel12138.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"7b85c17f811d8b378b3be880558937c6","google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?7b85c17f811d8b378b3be880558937c6";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yintel&#39;s BLOG</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法能力提升计划 Algorithm Capability Enhancement Program"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-01 10:21" pubdate>
          2024年4月1日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          60k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          503 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法能力提升计划 Algorithm Capability Enhancement Program</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>写在前面：<br>督促自己学习，顺便记录题解</p>
</blockquote>
<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><ul>
<li>5&#x2F;19 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens-ii/">52. N 皇后 II</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/interleaving-string/">97. 交错字符串</a>（昨天尸体不舒服，所以没做，哈哈哈给自己找了个借口，不过今天补上）</li>
<li>5&#x2F;17 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/game-of-life/">289. 生命游戏</a></li>
<li>5&#x2F;16 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></li>
<li>5&#x2F;15 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></li>
<li>5&#x2F;14 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></li>
<li>5&#x2F;13 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></li>
<li>5&#x2F;11 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/snakes-and-ladders/">909. 蛇梯棋</a>（感觉有点懈怠了，现在刷题有种例行公事的感觉，没有当初的那种激情了）</li>
<li>5&#x2F;10 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/clone-graph/">133. 克隆图</a></li>
<li>5&#x2F;9 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a>（重温一下岛屿数量，经典dfs）</li>
<li>5&#x2F;8 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a>（今天全是层序遍历）</li>
<li>5&#x2F;7 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a>（二叉树的部分终于完结了<em>★,°</em>:.☆(￣▽￣)&#x2F;$:<em>.°★</em> 。）</li>
<li>5&#x2F;6 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>（今天这个第一个题有点难度，理解了半天，coze也不是完全靠谱呀）</li>
<li>5&#x2F;5 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a>（这两道题的思路基本一样，所以做一个就能做另一个）</li>
<li>5&#x2F;4 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a>（五一给自己放了个假~看来复习的事情要提上日程了，看了最开始做的题，已经不知道怎么做了……）</li>
<li>4&#x2F;30 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></li>
<li>4&#x2F;29 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a>（对二叉树的理解还是不够，还是得好好复习）</li>
<li>4&#x2F;28 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a>（今天开始做一些二叉树的题目，适时可以看看之前的数据结构PPT）</li>
<li>4&#x2F;27 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a>（今天感觉有点懈怠了，请继续加油！人在做，天在看）</li>
<li>4&#x2F;26 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/simplify-path/">71. 简化路径</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></li>
<li>4&#x2F;25 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></li>
<li>4&#x2F;24 更新🌟<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>、🌟<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></li>
<li>4&#x2F;23 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a>、🌟<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>（堆和动态规划）</li>
<li>4&#x2F;22 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></li>
<li>4&#x2F;21 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></li>
<li>4&#x2F;20 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></li>
<li>4&#x2F;19 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/">201. 数字范围按位与</a>（位运算）、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></li>
<li>4&#x2F;18 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a></li>
<li>4&#x2F;17 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-bits/">190. 颠倒二进制位</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-binary/">67. 二进制求和</a></li>
<li>4&#x2F;16 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a>（回溯day~）</li>
<li>4&#x2F;15 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a>（有点没有带脑子）</li>
<li>4&#x2F;14 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a>（生病了leetcode也不能停！）</li>
<li>4&#x2F;13 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></li>
<li>4&#x2F;12 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/summary-ranges/">228. 汇总区间</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></li>
<li>4&#x2F;11 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></li>
<li>4&#x2F;10 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-pattern/">290. 单词规律</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/isomorphic-strings/">205. 同构字符串</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a>（三个easy）</li>
<li>4&#x2F;9 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></li>
<li>4&#x2F;8 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-points-on-a-line/">149. 直线上最多的点数</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></li>
<li>4&#x2F;7 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/h-index/">274. H 指数</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></li>
<li>4&#x2F;3 更新<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和</a></li>
</ul>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>（手动更新好累，暂时不更新了吧~）</p>
<h3 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加与搜索单词 - 数据结构设计</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordDictionary</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>            self.children = &#123;&#125;<br>            self.isEndOfWord = <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 这个题目应该是要使用字典树来实现的</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.root = self.TrieNode()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addWord</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = self.root<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:<br>                node.children[char] = self.TrieNode()<br>            node = node.children[char]<br>        node.isEndOfWord = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 使用dfs进行遍历</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node: self.TrieNode, i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(word):<br>                <span class="hljs-keyword">return</span> node.isEndOfWord<br>            <span class="hljs-keyword">if</span> word[i] == <span class="hljs-string">&#x27;.&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">any</span>(dfs(child, i+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children.values())<br>            <span class="hljs-keyword">if</span> word[i] <span class="hljs-keyword">in</span> node.children:<br>                <span class="hljs-keyword">return</span> dfs(node.children[word[i]], i+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> dfs(self.root, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>
<h3 id="52-N-皇后-II"><a href="#52-N-皇后-II" class="headerlink" title="52. N 皇后 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens-ii/">52. N 皇后 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># N 皇后 II</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">totalNQueens</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 经典dfs问题</span><br>    <span class="hljs-comment"># 需要创建visit数组（这里不固定所以很难做到）</span><br>    <span class="hljs-comment"># 通过比较对角线上的和和差判断是否冲突</span><br>    result = [<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">queens, xyDiff, xySum</span>):<br>        p = <span class="hljs-built_in">len</span>(queens)<br>        <span class="hljs-keyword">if</span> p == n:<br>            result[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> queens <span class="hljs-keyword">and</span> p-q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> xyDiff <span class="hljs-keyword">and</span> p+q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> xySum:<br>                dfs(queens + [q], xyDiff+[p-q], xySum+[p+q])<br>    dfs([], [], [])<br>    <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>
<h3 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubarraySumCircular</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 虽然数组变成了环形</span><br>    <span class="hljs-comment"># 但是我觉得还是可以用动态规划的思想来解决</span><br>    <span class="hljs-comment"># 对于数组中环状连续子数组的最大和问题，实际上可以分为两种情况考虑：</span><br>    <span class="hljs-comment"># 非环形子数组的最大和：这可以通过常规的动态规划（Kadane算法）来解决。遍历一次数组，找到非环形子数组可能的最大和。</span><br>    <span class="hljs-comment"># 跨越环形边界的子数组的最大和：这一部分稍微复杂一点，可以通过计算总和减去非环形子数组的最小和来得到。为此，需要再次应用动态规划来找到非环形子数组的最小和。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kadane</span>(<span class="hljs-params">nums</span>):<br>        dp = [nums[<span class="hljs-number">0</span>]] * <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br><br>    <span class="hljs-comment"># 首先求正常数组的最大值</span><br>    maxNormal = kadane(nums)<br>    <span class="hljs-keyword">if</span> maxNormal &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> maxNormal<br>    maxCircular = <span class="hljs-built_in">sum</span>(nums) + kadane([-x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxNormal, maxCircular)<br></code></pre></td></tr></table></figure>
<h3 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/interleaving-string/">97. 交错字符串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 交错字符串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isInterleave</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span>, s3: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 既然是动态规划的题目</span><br>    <span class="hljs-comment"># 那就考虑创建dp数组</span><br>    l1, l2, l3 = <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">len</span>(s3)<br>    <span class="hljs-keyword">if</span> l1 + l2 != l3 : <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 创建一个l1+1xl2+1大小的数组</span><br>    <span class="hljs-comment"># dp[i][j]表示s3的前i+j个字符是否能被s1的前i个字符和s2的前j个字符交错组成。</span><br>    dp = [[<span class="hljs-literal">False</span>] * (l2 + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l1 + <span class="hljs-number">1</span>)]<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 如果当前字符s3[i+j-1]等于s1[i-1]且dp[i-1][j]是true，那么dp[i][j]也应该是true；</span><br>    <span class="hljs-comment"># 如果当前字符s3[i+j-1]等于s2[j-1]且dp[i][j-1]是true，那么dp[i][j]也应该是true。</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,l1+<span class="hljs-number">1</span>):<br>        dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> s1[i-<span class="hljs-number">1</span>] == s3[i-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2 +<span class="hljs-number">1</span>):<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> s2[j-<span class="hljs-number">1</span>] == s3[j-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l1+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> s1[i-<span class="hljs-number">1</span>] == s3[i+j-<span class="hljs-number">1</span>]:<br>                dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j]<br>            <span class="hljs-keyword">if</span> s2[j-<span class="hljs-number">1</span>] == s3[i+j-<span class="hljs-number">1</span>]:<br>                dp[i][j] |= dp[i][j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[l1][l2]<br></code></pre></td></tr></table></figure>
<h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最大正方形</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maximalSquare</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br><br>    <span class="hljs-comment"># 这个题目的状态转移方程大致如下</span><br>    <span class="hljs-comment"># 检查点dp[i][j] 需要检测左边、上边、左上边</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> matrix[<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    maxSide = <span class="hljs-number">0</span><br><br>    rows, cols = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    dp = [[<span class="hljs-number">0</span>] * cols <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows)]<br><br>    <span class="hljs-comment"># 遍历dp数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">0</span>:<br>                    dp[i][j] = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>],<br>                                   dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>                maxSide = <span class="hljs-built_in">max</span>(maxSide, dp[i][j])<br>    <span class="hljs-keyword">return</span> maxSide ** <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<h3 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/game-of-life/">289. 生命游戏</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生命游戏</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gameOfLife</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Do not return anything, modify board in-place instead.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 为了原地更新 board，但同时需要访问原始 board 状态，您可以使用额外的变量来表达更多状态。例如，可以规定：</span><br>    <span class="hljs-comment"># -1 表示这个细胞之前是活的，现在死了。 （这样才能用abs进行状态判断！！！）</span><br>    <span class="hljs-comment"># 3 表示这个细胞之前是死的，现在活了。</span><br><br>    rows, cols = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment"># 方向向量</span><br>    directions = [(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br>    <br>    <span class="hljs-comment"># 计算周围活着的邻居的数量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countLiveNeighbor</span>(<span class="hljs-params">r, c</span>):<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> directions:<br>            nr, nc = r + dr, c + dc<br>            <span class="hljs-comment"># 确保在合法区域内，并取绝对值判断原始状态</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nr &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nc &lt; cols <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(board[nr][nc]) == <span class="hljs-number">1</span>:<br>                count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br>    <br>    <span class="hljs-comment"># 第一遍遍历：基于原始状态更新为中间状态（2和3）</span><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            liveNeighbor = countLiveNeighbor(r, c)<br>            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (liveNeighbor &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> liveNeighbor &gt; <span class="hljs-number">3</span>):<br>                board[r][c] = -<span class="hljs-number">1</span>  <span class="hljs-comment"># 编码死亡状态</span><br>            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> liveNeighbor == <span class="hljs-number">3</span>:<br>                board[r][c] = <span class="hljs-number">3</span>  <span class="hljs-comment"># 编码新生状态</span><br>    <br>    <span class="hljs-comment"># 第二遍遍历：将中间状态解码为新状态</span><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            <span class="hljs-keyword">if</span> board[r][c] == -<span class="hljs-number">1</span>:<br>                board[r][c] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 解码死亡状态</span><br>            <span class="hljs-keyword">elif</span> board[r][c] == <span class="hljs-number">3</span>:<br>                board[r][c] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 解码新生状态</span><br></code></pre></td></tr></table></figure>
<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉搜索树中第K小的元素</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目需要利用二叉搜索树的性质</span><br>    <span class="hljs-comment"># 即node.left.val &lt; node.val &lt; node.right.val</span><br>    <span class="hljs-comment"># 所以最小的绝对差</span><br>    <span class="hljs-comment"># 一定是相邻的节点</span><br>    <span class="hljs-comment"># 为了找到给定二叉搜索树中任意两节点的最小绝对差值，您可以对二叉搜索树进行中序遍历。由于二叉搜索树的中序遍历结果是一个递增的序列，那么任意两个相邻节点的差值将会是节点间的最小差值。</span><br>    inOrder = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inOrderTraverse</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inOrder) &gt;= k:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span><br>        inOrderTraverse(node.left)<br>        inOrder.append(node.val)<br>        inOrderTraverse(node.right)<br><br>    inOrderTraverse(root)<br><br>    <span class="hljs-keyword">return</span> inOrder[k-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉搜索树的最小绝对差</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMinimumDifference</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目需要利用二叉搜索树的性质</span><br>    <span class="hljs-comment"># 即node.left.val &lt; node.val &lt; node.right.val</span><br>    <span class="hljs-comment"># 所以最小的绝对差</span><br>    <span class="hljs-comment"># 一定是相邻的节点</span><br>    <span class="hljs-comment"># 为了找到给定二叉搜索树中任意两节点的最小绝对差值，您可以对二叉搜索树进行中序遍历。由于二叉搜索树的中序遍历结果是一个递增的序列，那么任意两个相邻节点的差值将会是节点间的最小差值。</span><br>    inOrder = []<br>    self.minDiff = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inOrderTraverse</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span><br>        inOrderTraverse(node.left)<br>        <span class="hljs-keyword">if</span> inOrder:<br>            self.minDiff = <span class="hljs-built_in">min</span>(self.minDiff, node.val - inOrder[-<span class="hljs-number">1</span>])<br>        inOrder.append(node.val)<br>        inOrderTraverse(node.right)<br><br>    inOrderTraverse(root)<br><br>    <span class="hljs-keyword">return</span> self.minDiff<br></code></pre></td></tr></table></figure>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 验证二叉搜索树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 上述解法是狭隘的</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params">node, low=<span class="hljs-built_in">float</span>(<span class="hljs-params"><span class="hljs-string">&#x27;-inf&#x27;</span></span>), high=<span class="hljs-built_in">float</span>(<span class="hljs-params"><span class="hljs-string">&#x27;inf&#x27;</span></span>)</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (low &lt; node.val &lt; high):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 递归检查</span><br>        <span class="hljs-keyword">return</span> (validate(node.left, low, node.val) <span class="hljs-keyword">and</span><br>                validate(node.right, node.val, high))<br>    <span class="hljs-keyword">return</span> validate(root)<br></code></pre></td></tr></table></figure>
<h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单词接龙</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ladderLength</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br><br>    <span class="hljs-comment"># 首先建图</span><br>    bankSet = <span class="hljs-built_in">set</span>(wordList)<br>    <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> bankSet:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canTransform</span>(<span class="hljs-params">word1, word2</span>):<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c1, c2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(word1, word2):<br>            <span class="hljs-keyword">if</span> c1 != c2:<br>                count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count == <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 初始化队列</span><br>    queue = deque([(beginWord, <span class="hljs-number">1</span>)])<br><br>    <span class="hljs-keyword">while</span> queue:<br>        currentWord, stepCount = queue.popleft()<br>        <span class="hljs-keyword">if</span> currentWord == endWord:<br>            <span class="hljs-comment"># 第一个找到的一定是最小的</span><br>            <span class="hljs-keyword">return</span> stepCount<br>        <span class="hljs-comment"># 继续寻找</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(currentWord)):<br>            <span class="hljs-comment"># 按照26个英文字母进行遍历</span><br>            <span class="hljs-comment"># 对当前的word进行构造，如果能够构造出一个在bankset中的单词就加入队列</span><br>            <span class="hljs-comment"># 由于只能使用一次，所以删除bankset中的单词</span><br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:<br>                nextWord = currentWord[:i] + c + currentWord[i+<span class="hljs-number">1</span>:]<br>                <span class="hljs-keyword">if</span> canTransform(nextWord, currentWord) <span class="hljs-keyword">and</span> nextWord <span class="hljs-keyword">in</span> bankSet:<br>                    bankSet.remove(nextWord)<br>                    queue.append((nextWord, stepCount + <span class="hljs-number">1</span>))<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机链表的复制</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Optional[Node]&#x27;</span>:<br>    <span class="hljs-comment"># 这个题目的难点就在于随机节点的复制</span><br>    <span class="hljs-comment"># 目前想到的方法就是使用一个dict去存储映射关系</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 创建对应关系</span><br>    o2n = &#123;&#125;<br><br>    <span class="hljs-comment"># 第一次遍历,创建新的链表</span><br>    current = head<br>    <span class="hljs-keyword">while</span> current:<br>        copy = Node(current.val)<br>        o2n[current] = copy<br>        current = current.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-comment"># 再次遍历,建立random的对应关系</span><br>    current = head<br>    <span class="hljs-keyword">while</span> current:<br>        <span class="hljs-keyword">if</span> current.<span class="hljs-built_in">next</span>:<br>            o2n[current].<span class="hljs-built_in">next</span> = o2n[current.<span class="hljs-built_in">next</span>]<br>        <span class="hljs-keyword">if</span> current.random:<br>            o2n[current].random = o2n[current.random]<br>        current = current.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">return</span> o2n[head]<br></code></pre></td></tr></table></figure>
<h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># K 个一组翻转链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 思路就是先分解成子问题,再按照标准的反转方法进行反转</span><br>    dummy = ListNode(<span class="hljs-number">0</span>)<br>    dummy.<span class="hljs-built_in">next</span> = head<br>    prev, end = dummy, dummy<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">start</span>):<br>        prev = <span class="hljs-literal">None</span><br>        curr = start<br>        <span class="hljs-keyword">while</span> curr:<br>            nextTemp = curr.<span class="hljs-built_in">next</span><br>            curr.<span class="hljs-built_in">next</span> = prev<br>            <span class="hljs-comment"># 移动到下一个位置</span><br>            prev = curr<br>            curr = nextTemp<br>        <span class="hljs-keyword">return</span> prev<br><br>    <span class="hljs-keyword">while</span> end.<span class="hljs-built_in">next</span>:<br>        <span class="hljs-comment"># 找到每组的k个节点</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            end = end.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> end:<br>                <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 记录next</span><br>        start = prev.<span class="hljs-built_in">next</span><br>        <span class="hljs-built_in">next</span> = end.<span class="hljs-built_in">next</span><br><br>        end.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 反转当前k个节点</span><br>        prev.<span class="hljs-built_in">next</span> = reverse(start)<br>        start.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 重新确定prev的位置</span><br>        prev = start<br>        end = prev<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>

<h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">findOrder</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-comment"># 这个题目依然是拓扑排序</span><br>    <span class="hljs-comment"># 先把1的代码抄过来</span><br>    graph = defaultdict(<span class="hljs-built_in">list</span>)<br>    indegrees = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br><br>    <span class="hljs-comment"># 构建图</span><br>    <span class="hljs-keyword">for</span> cur,pre <span class="hljs-keyword">in</span> prerequisites:<br>        graph[pre].append(cur)<br>        indegrees[cur] += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 进行拓扑排序</span><br>    queue = deque([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses) <span class="hljs-keyword">if</span> indegrees[i] == <span class="hljs-number">0</span>] )<br><br>    <span class="hljs-comment"># 结果数组</span><br>    res = []<br>    finishedCourse = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span> queue:<br>        course = queue.popleft()<br>        <span class="hljs-comment"># 课程数+1</span><br>        finishedCourse += <span class="hljs-number">1</span><br>        res.append(course)<br>        <span class="hljs-comment"># 入度-1</span><br>        <span class="hljs-keyword">for</span> nextCourse <span class="hljs-keyword">in</span> graph[course]:<br>            indegrees[nextCourse] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> indegrees[nextCourse] == <span class="hljs-number">0</span>:<br>                queue.append(nextCourse)<br>    <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> finishedCourse == numCourses <span class="hljs-keyword">else</span> []<br></code></pre></td></tr></table></figure>
<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">canFinish</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 这就是一个图的拓扑排序问题</span><br>    graph = defaultdict(<span class="hljs-built_in">list</span>)<br>    indegrees = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br><br>    <span class="hljs-comment"># 构建图</span><br>    <span class="hljs-keyword">for</span> cur,pre <span class="hljs-keyword">in</span> prerequisites:<br>        graph[pre].append(cur)<br>        indegrees[cur] += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 进行拓扑排序</span><br>    queue = deque([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses) <span class="hljs-keyword">if</span> indegrees[i] == <span class="hljs-number">0</span>] )<br><br>    finishedCourse = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span> queue:<br>        course = queue.popleft()<br>        <span class="hljs-comment"># 课程数+1</span><br>        finishedCourse += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 入度-1</span><br>        <span class="hljs-keyword">for</span> nextCourse <span class="hljs-keyword">in</span> graph[course]:<br>            indegrees[nextCourse] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> indegrees[nextCourse] == <span class="hljs-number">0</span>:<br>                queue.append(nextCourse)<br>    <span class="hljs-keyword">return</span> finishedCourse == numCourses<br>    <br></code></pre></td></tr></table></figure>
<h3 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最小基因变化</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minMutation</span>(<span class="hljs-params">self, startGene: <span class="hljs-built_in">str</span>, endGene: <span class="hljs-built_in">str</span>, bank: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目的想法就是先建图</span><br>    <span class="hljs-comment"># 基因库中的基因是可以相互转换的，并且start可以转换到基因库中的基因</span><br>    <span class="hljs-comment"># 因此建图后可以通过bfs，找到最小的转变次数</span><br>    <span class="hljs-comment"># 一次基因变化就意味着这个基因序列中的一个字符发生了变化</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidMutation</span>(<span class="hljs-params">gene1, gene2</span>):<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gene1)):<br>            <span class="hljs-keyword">if</span> gene1[i] != gene2[i]:<br>                count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> count == <span class="hljs-number">1</span><br><br>    bankSet = <span class="hljs-built_in">set</span>(bank)<br>    <span class="hljs-keyword">if</span> endGene <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> bankSet:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>    queue = deque([(startGene, <span class="hljs-number">0</span>)])<br>    <span class="hljs-keyword">while</span> queue:<br>        currGene, mutations = queue.popleft()<br>        <span class="hljs-keyword">if</span> currGene == endGene:<br>            <span class="hljs-keyword">return</span> mutations<br>        <span class="hljs-keyword">for</span> gene <span class="hljs-keyword">in</span> bankSet.copy():<br>            <span class="hljs-keyword">if</span> isValidMutation(currGene, gene):<br>                bankSet.remove(gene)<br>                queue.append((gene, mutations + <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="909-蛇梯棋"><a href="#909-蛇梯棋" class="headerlink" title="909. 蛇梯棋"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/snakes-and-ladders/">909. 蛇梯棋</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 蛇梯棋</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">snakesAndLadders</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 读题读了半天</span><br>    <span class="hljs-comment"># 感觉可以用一个模拟解决</span><br>    <span class="hljs-comment"># 但这个是放在bfs里面的</span><br>    <span class="hljs-comment"># 先抄一下</span><br>    <span class="hljs-comment"># 因此，BFS策略天然适合用于解决在无权图（即所有边的权重都相同的图）中找到最短路径的问题</span><br>    n = <span class="hljs-built_in">len</span>(board)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">s</span>):<br>        quot, rem = <span class="hljs-built_in">divmod</span>(s - <span class="hljs-number">1</span>, n)<br>        row = n - <span class="hljs-number">1</span> - quot<br>        col = rem <span class="hljs-keyword">if</span> row % <span class="hljs-number">2</span> != (n % <span class="hljs-number">2</span>) <span class="hljs-keyword">else</span> n - <span class="hljs-number">1</span> - rem<br>        <span class="hljs-keyword">return</span> row, col<br><br>    queue = deque([<span class="hljs-number">1</span>])<br>    visited = <span class="hljs-built_in">set</span>()<br>    step = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span> queue:<br>        size = <span class="hljs-built_in">len</span>(queue)<br>        s = queue.popleft()<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">if</span> s == n * n:<br>                <span class="hljs-keyword">return</span> step<br>            <span class="hljs-comment"># 模拟骰子🎲</span><br>            <span class="hljs-keyword">for</span> s2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s + <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(s+<span class="hljs-number">6</span>, n*n) + <span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># 因为是平方，所以需要转换一下坐标</span><br>                r, c = get(s2)<br>                <span class="hljs-keyword">if</span> board[r][c] != -<span class="hljs-number">1</span>:<br>                    s2 = board[r][c]<br>                <span class="hljs-keyword">if</span> s2 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                    visited.add(s2)<br>                    queue.append(s2)<br>        step += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 如果还没有到达终点说明无法到达</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calcEquation</span>(<span class="hljs-params">self, equations: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], values: <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>], queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>    <span class="hljs-comment"># 替换成有向图的遍历问题</span><br>    <span class="hljs-comment"># 除法的算式作为节点和边</span><br>    <span class="hljs-comment"># 建立图</span><br>    self.graph = defaultdict(<span class="hljs-built_in">dict</span>)<br>    <span class="hljs-comment"># 将算式和结果加入（倒数也要加入）</span><br>    <span class="hljs-keyword">for</span> (dividend, divisor), value <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(equations, values):<br>        self.graph[dividend][divisor] = value<br>        self.graph[divisor][dividend] = <span class="hljs-number">1.0</span> / value<br><br>    <span class="hljs-comment"># 进行dfs遍历</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">start, end, visited</span>):<br>        <span class="hljs-keyword">if</span> start <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.graph:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0</span><br>        <span class="hljs-keyword">if</span> start == end:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span><br>        visited.add(start)<br><br>        <span class="hljs-keyword">for</span> neighbor, value <span class="hljs-keyword">in</span> self.graph[start].items():<br>            <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">in</span> visited:<br>                <span class="hljs-keyword">continue</span><br><br>            visited.add(neighbor)<br><br>            temp = dfs(neighbor, end, visited)<br>            <span class="hljs-keyword">if</span> temp != - <span class="hljs-number">1.0</span>:<br>                <span class="hljs-keyword">return</span> value * temp<br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1.0</span><br><br>    <span class="hljs-keyword">return</span> [dfs(Cj, Dj, <span class="hljs-built_in">set</span>()) <span class="hljs-keyword">for</span> Cj, Dj <span class="hljs-keyword">in</span> queries]<br></code></pre></td></tr></table></figure>

<h3 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/clone-graph/">133. 克隆图</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cloneGraph</span>(<span class="hljs-params">self, node: <span class="hljs-type">Optional</span>[<span class="hljs-string">&#x27;Node&#x27;</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[<span class="hljs-string">&#x27;Node&#x27;</span>]:<br>    <span class="hljs-comment"># 需要深拷贝</span><br>    <span class="hljs-comment"># 使用dfs进行遍历</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    visited = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> visited:<br>            <span class="hljs-keyword">return</span> visited[node]<br><br>        clonedNode = Node(node.val)<br>        visited[node] = clonedNode<br><br>        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> node.neighbors:<br>            clonedNodeNeighbor = dfs(neighbor)<br>            clonedNode.neighbors.append(clonedNodeNeighbor)<br><br>        <span class="hljs-keyword">return</span> clonedNode<br>    <span class="hljs-keyword">return</span> dfs(node)<br></code></pre></td></tr></table></figure>
<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 被围绕的区域</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-comment"># 感觉和岛屿数量差不多 只是需要稍微修改一下代码</span><br>    <span class="hljs-comment"># 但是实际上的解决思路应该是</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> board[<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= <span class="hljs-built_in">len</span>(board) <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> board[i][j] != <span class="hljs-string">&#x27;O&#x27;</span>:<br>            <span class="hljs-keyword">return</span><br>        board[i][j] = <span class="hljs-string">&#x27;A&#x27;</span><br>        dfs(i, j+<span class="hljs-number">1</span>)<br>        dfs(i+<span class="hljs-number">1</span>, j)<br>        dfs(i-<span class="hljs-number">1</span>, j)<br>        dfs(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 对边界的O进行处理</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board)):<br>        dfs(i, <span class="hljs-number">0</span>)<br>        dfs(i, <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])):<br>        dfs(<span class="hljs-number">0</span>, j)<br>        dfs(<span class="hljs-built_in">len</span>(board)-<span class="hljs-number">1</span>, j)<br>    <span class="hljs-comment"># 现在情况下，与边界O相连的区域已经全是A了，只需要将剩下的O替换成X即可，A替换成O</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span><br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>:<br>                board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span><br><br></code></pre></td></tr></table></figure>
<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 岛屿数量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>        <span class="hljs-comment"># 如果触碰到岛屿的边界或者是地图的边界，直接返回，不会进行下一步的操作了</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= <span class="hljs-built_in">len</span>(grid) <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 核心思路就是每次找到一个1 就把它和他周围的1标记成0 记录为一块岛屿</span><br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>        <span class="hljs-comment"># 探查周围的岛屿数量</span><br>        dfs(i+<span class="hljs-number">1</span>, j)<br>        dfs(i-<span class="hljs-number">1</span>, j)<br>        dfs(i, j+<span class="hljs-number">1</span>)<br>        dfs(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                dfs(i, j)<br>                count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure>
<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">zigzagLevelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 应该是需要加个flag记录是否翻转</span><br>    res = []<br>    queue = deque()<br>    isFlip = <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 首先加入队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> res<br><br>    queue.append(root)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 首先需要记录当前层的长度</span><br>        levelLen = <span class="hljs-built_in">len</span>(queue)<br>        levelRes = []<br>        <span class="hljs-comment"># 层序遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(levelLen):<br>            node = queue.popleft()<br>            <span class="hljs-keyword">if</span> isFlip:<br>                <span class="hljs-comment"># 应该是改变元素插入的顺序，而不是遍历方式</span><br>                levelRes.insert(<span class="hljs-number">0</span>, node.val)<br>            <span class="hljs-keyword">else</span>:<br>                levelRes.append(node.val)<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>        isFlip = <span class="hljs-keyword">not</span> isFlip<br>        res.append(levelRes)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树的层序遍历</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    res = []<br>    queue = deque()<br>    <span class="hljs-comment"># 首先加入队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> res<br><br>    queue.append(root)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 首先需要记录当前层的长度</span><br>        levelLen = <span class="hljs-built_in">len</span>(queue)<br>        levelRes = []<br>        <span class="hljs-comment"># 层序遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(levelLen):<br>            node = queue.popleft()<br>            levelRes.append(node.val)<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>        <span class="hljs-comment"># 计算平均值</span><br>        res.append(levelRes)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树的层平均值</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfLevels</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>    res = []<br>    queue = deque()<br>    <span class="hljs-comment"># 首先加入队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> res<br><br>    queue.append(root)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 首先需要记录当前层的长度</span><br>        levelLen = <span class="hljs-built_in">len</span>(queue)<br>        levelSum = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 层序遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(levelLen):<br>            node = queue.popleft()<br>            <span class="hljs-comment"># 如果是最后一个节点</span><br>            levelSum += node.val<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>        <span class="hljs-comment"># 计算平均值</span><br>        res.append(levelSum/levelLen)<br>    <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 二叉树的右视图</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rightSideView</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-comment"># 右视图</span><br>    <span class="hljs-comment"># 多分析几个情况</span><br>    <span class="hljs-comment"># 应该可以用递归解决</span><br>    <span class="hljs-comment"># 还和层高有关系，那么应该用层序遍历，将每一层的最后一个节点加入res</span><br>    res = []<br>    queue = deque()<br>    <span class="hljs-comment"># 首先加入队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> res<br><br>    queue.append(root)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 首先需要记录当前层的长度</span><br>        levelLen = <span class="hljs-built_in">len</span>(queue)<br><br>        <span class="hljs-comment"># 层序遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(levelLen):<br>            node = queue.popleft()<br>            <span class="hljs-comment"># 如果是最后一个节点</span><br>            <span class="hljs-keyword">if</span> i == levelLen - <span class="hljs-number">1</span>:<br>                res.append(node.val)<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树中的最大路径和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目感觉有点像动态规划的思路</span><br>    self.maxSum = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        leftGain = <span class="hljs-built_in">max</span>(dfs(node.left), <span class="hljs-number">0</span>)<br>        rightGain = <span class="hljs-built_in">max</span>(dfs(node.right), <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 当前节点所在的路径最大值</span><br>        pathSum = node.val + leftGain + rightGain<br><br>        <span class="hljs-comment"># 判断当前和全局最大值的大小关系</span><br>        self.maxSum = <span class="hljs-built_in">max</span>(self.maxSum, pathSum)<br>        <span class="hljs-comment"># 为什么只返回其中一边的gain呢？ 避免重复</span><br><br>        <span class="hljs-comment"># 一个节点要么自身成为边的根节点，要么成为贡献者</span><br>        <span class="hljs-comment"># 所以他的返回值应该是单边的gain</span><br>        <span class="hljs-keyword">return</span> node.val + <span class="hljs-built_in">max</span>(leftGain, rightGain)<br><br>    dfs(root)<br>    <span class="hljs-keyword">return</span> self.maxSum<br></code></pre></td></tr></table></figure>
<h3 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉搜索树迭代器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>):<br>        <span class="hljs-comment"># 初始化一个空栈</span><br>        self.stack = []<br>        <span class="hljs-comment"># 将左子树节点加入</span><br>        self.leftmostInorder(root)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">leftmostInorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-keyword">while</span> root:<br>            self.stack.append(root)<br>            root = root.left<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        topmostNode = self.stack.pop()<br><br>        <span class="hljs-keyword">if</span> topmostNode.right:<br>            self.leftmostInorder(topmostNode.right)<br><br>        <span class="hljs-keyword">return</span> topmostNode.val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stack) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><ul>
<li>优化版<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 完全二叉树的节点个数</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">countNodes</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countHeight</span>(<span class="hljs-params">node</span>):<br>        height = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> node:<br>            node = node.left<br>            height += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> height<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 分别求左右子树的高度</span><br>    leftHeight = countHeight(root.left)<br>    rightHeight = countHeight(root.right)<br><br>    <span class="hljs-comment"># 判断左右子树的高度关系</span><br>    <span class="hljs-keyword">if</span> leftHeight == rightHeight:<br>        <span class="hljs-comment"># 如果左右子树高度相等</span><br>        <span class="hljs-comment"># 说明现在左子树是满二叉树，需要递归判断右子树的情况</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; leftHeight) - <span class="hljs-number">1</span> + self.countNodes(root.right) + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 说明现在右子树是满的，需要递归判断左子树</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; rightHeight) - <span class="hljs-number">1</span> + self.countNodes(root.left) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li>
<li>普通版<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通版</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">countNodes</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树的最近公共祖先</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:<br>    <span class="hljs-comment"># 感觉可以转换一下思路</span><br>    <span class="hljs-comment"># 与其说是找最近公共祖先,不如说在当前root下能否找到p和q</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> root == p <span class="hljs-keyword">or</span> root == q:<br>        <span class="hljs-keyword">return</span> root<br><br>    <span class="hljs-comment"># 在左子树中找pq</span><br>    left = self.lowestCommonAncestor(root.left, p, q)<br>    right = self.lowestCommonAncestor(root.right, p, q)<br><br>    <span class="hljs-comment"># 如果两个节点都不为空，可以直接返回了</span><br>    <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> right:<br>        <span class="hljs-keyword">return</span> root<br>    <span class="hljs-comment"># 否则返回不为空的那半颗树的根节点</span><br>    <span class="hljs-keyword">return</span> left <span class="hljs-keyword">if</span> left <span class="hljs-keyword">else</span> right<br></code></pre></td></tr></table></figure>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 路径总和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, <span class="hljs-built_in">sum</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-built_in">sum</span> += node.val<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span> == targetSum<br><br>        <span class="hljs-comment"># 递归判断左右子树</span><br>        <span class="hljs-keyword">return</span> dfs(node.left, <span class="hljs-built_in">sum</span>) <span class="hljs-keyword">or</span> dfs(node.right, <span class="hljs-built_in">sum</span>)<br>    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>
<h3 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求根节点到叶节点数字之和</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sumNumbers</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 递归（循环）思路</span><br>    <span class="hljs-comment"># root * 10 + val</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, currentNumber</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        currentNumber = currentNumber * <span class="hljs-number">10</span> + node.val<br><br>        <span class="hljs-comment"># 如果是叶子节点，就直接返回</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>            <span class="hljs-keyword">return</span> currentNumber<br><br>        <span class="hljs-comment"># 递归计算左右zishu</span><br>        leftSum = dfs(node.left, currentNumber)<br>        rightSum = dfs(node.right, currentNumber)<br><br>        <span class="hljs-keyword">return</span> leftSum + rightSum<br><br>    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>
<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树展开为链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Do not return anything, modify root in-place instead.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <br>    <br>    self.flatten(root.left)<br>    self.flatten(root.right)<br><br>    <span class="hljs-comment"># 暂时保存右子树</span><br>    tempRight = root.right<br><br>    <span class="hljs-comment"># 将flatten以后的进行操作</span><br>    root.right = root.left<br>    root.left = <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 一路遍历到叶子节点</span><br>    <span class="hljs-keyword">while</span> root.right:<br>        root = root.right<br>    <span class="hljs-comment"># 将原来的右子树拼接在最后</span><br>    root.right = tempRight<br></code></pre></td></tr></table></figure>
<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 填充每个节点的下一个右侧节点指针 II</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>, left: <span class="hljs-string">&#x27;Node&#x27;</span> = <span class="hljs-literal">None</span>, right: <span class="hljs-string">&#x27;Node&#x27;</span> = <span class="hljs-literal">None</span>, <span class="hljs-built_in">next</span>: <span class="hljs-string">&#x27;Node&#x27;</span> = <span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>    <span class="hljs-comment"># 看到题目的要求 想到了二叉树的层序遍历</span><br>    <span class="hljs-comment"># 层序遍历需要使用队列</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 初始化队列，将根节点加入</span><br>    queue = deque([root])<br><br>    <span class="hljs-keyword">while</span> queue:<br>        size = <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-comment"># 遍历当前层的节点</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            node = queue.popleft()<br>            <span class="hljs-comment"># 如果不是最右边的节点，则将next指针指向右边的</span><br>            <span class="hljs-keyword">if</span> i &lt; size - <span class="hljs-number">1</span>:<br>                node.<span class="hljs-built_in">next</span> = queue[<span class="hljs-number">0</span>]<br><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>    <span class="hljs-keyword">return</span> root<br>    <br></code></pre></td></tr></table></figure>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><ul>
<li>这两个题都利用了一个性质，左右子树的元素个数是一致的<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从前序与中序遍历序列构造二叉树</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>    <span class="hljs-comment"># 给定的输入如下：</span><br>    <span class="hljs-comment"># 前序遍历：[3, 9, 20, 15, 7]</span><br>    <span class="hljs-comment"># 中序遍历：[9, 3, 15, 20, 7]</span><br>    <span class="hljs-comment"># 首先，根据前序遍历，我们知道根节点是3。</span><br>    <span class="hljs-comment"># 对于中序遍历[9, 3, 15, 20, 7]：</span><br>    <span class="hljs-comment"># 根节点3之前的所有节点[9]构成左子树。</span><br>    <span class="hljs-comment"># 根节点3之后的所有节点[15, 20, 7]构成右子树。</span><br>    <span class="hljs-comment"># 接下来，我们就有了两个子问题：</span><br>    <span class="hljs-comment"># 左子树的前序遍历是[9]，中序遍历是[9]。</span><br>    <span class="hljs-comment"># 右子树的前序遍历是[20, 15, 7]，中序遍历是[15, 20, 7]。</span><br>    <span class="hljs-comment"># 确定根节点：在前序遍历中找到树的根节点（序列的第一个元素）。</span><br>    <span class="hljs-comment"># 划分树的左右子树：在中序遍历序列中找到根节点，这样就可以确定左子树和右子树的节点。</span><br>    <span class="hljs-comment"># 递归构造子树：对于根节点的左侧和右侧序列，重复以上过程，构造左子树和右子树。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> inorder:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 第一个一定是根节点</span><br>    root = TreeNode(preorder[<span class="hljs-number">0</span>])<br>    mid = inorder.index(preorder[<span class="hljs-number">0</span>])<br><br>    root.left = self.buildTree(preorder[<span class="hljs-number">1</span>:mid+<span class="hljs-number">1</span>], inorder[:mid])<br>    root.right = self.buildTree(preorder[mid+<span class="hljs-number">1</span>:], inorder[mid+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从中序与后序遍历序列构造二叉树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], postorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>    <span class="hljs-comment"># 需要注意的是，后序遍历的最后一个节点一定是根节点，所以这个题目就很简单了</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> postorder:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 最后一个一定是根节点</span><br>    root = TreeNode(postorder[-<span class="hljs-number">1</span>])<br>    mid = inorder.index(postorder[-<span class="hljs-number">1</span>])<br><br>    root.left = self.buildTree(inorder[:mid+<span class="hljs-number">1</span>], postorder[:mid])<br>    root.right = self.buildTree(inorder[mid+<span class="hljs-number">1</span>:], postorder[mid:-<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>
<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对称二叉树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 判断对称这个简单</span><br>    <span class="hljs-comment"># 只需要递归的判断左右子树是否对称即可</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">left, right</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (left <span class="hljs-keyword">or</span> right):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (left <span class="hljs-keyword">and</span> right):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> left.val != right.val:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> dfs(left.left, right.right) <span class="hljs-keyword">and</span> dfs(left.right, right.left)<br><br>    <span class="hljs-keyword">return</span> dfs(root.left, root.right)<br></code></pre></td></tr></table></figure>
<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 翻转二叉树</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>    <span class="hljs-comment"># 需要翻转二叉树的左右子树</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 翻转左子树</span><br>    left = self.invertTree(root.left)<br><br>    <span class="hljs-comment"># 翻转右子树</span><br>    right = self.invertTree(root.right)<br><br>    <span class="hljs-comment"># 交换翻转后的节点</span><br>    root.left, root.right = right, left<br><br>    <span class="hljs-keyword">return</span> roots<br></code></pre></td></tr></table></figure>
<h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 相同的树</span><br><span class="hljs-comment"># 关键点还是在于遍历</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isSameTree</span>(<span class="hljs-params">self, p: <span class="hljs-type">Optional</span>[TreeNode], q: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 还得是题解</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> q:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> q:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> p.val != q.val:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 递归检查左右子树</span><br>    <span class="hljs-keyword">return</span> self.isSameTree(p.left, q.left) <span class="hljs-keyword">and</span> self.isSameTree(p.right, q.right)<br><br></code></pre></td></tr></table></figure>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树的最大深度</span><br><span class="hljs-comment"># 很简单的一道二叉树的遍历题，帮我回顾二叉树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 创建一个变量记录最大深度</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node: <span class="hljs-type">Optional</span>[TreeNode]</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        leftDepth = dfs(node.left)<br>        rightDepth = dfs(node.right)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftDepth, rightDepth) + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> dfs(root)<br></code></pre></td></tr></table></figure>
<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 创建两个附加头节点</span><br>    head1 = ListNode()<br>    head2 = ListNode()<br>    cur1 = head1<br>    cur2 = head2<br>    <span class="hljs-keyword">while</span> head:<br>        <span class="hljs-keyword">if</span> head.val &lt; x:<br>            cur1.<span class="hljs-built_in">next</span> = ListNode(head.val)<br>            cur1 = cur1.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">else</span>:<br>            cur2.<span class="hljs-built_in">next</span> = ListNode(head.val)<br>            cur2 = cur2.<span class="hljs-built_in">next</span><br>        head = head.<span class="hljs-built_in">next</span><br>    <span class="hljs-comment"># 拼接两个链表</span><br>    <span class="hljs-comment"># 注意拼接的位置</span><br>    cur1.<span class="hljs-built_in">next</span> = head2.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> head1.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>
<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateRight</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 这个题实际上不是翻转链表 而是旋转链表</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">or</span> k == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> head<br><br>    cur = head<br>    length = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> cur.<span class="hljs-built_in">next</span>:<br>        cur = cur.<span class="hljs-built_in">next</span><br>        length += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 形成环</span><br>    cur.<span class="hljs-built_in">next</span> = head<br><br>    <span class="hljs-comment"># 找到旋转后的链表的尾巴，从尾巴处切开就是新的链表</span><br>    tail = head<br>    steps = length - k % length<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(steps - <span class="hljs-number">1</span>):<br>        tail = tail.<span class="hljs-built_in">next</span><br><br>    newHead = tail.<span class="hljs-built_in">next</span><br>    tail.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> newHead<br></code></pre></td></tr></table></figure>
<h3 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/simplify-path/">71. 简化路径</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简化路径</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">simplifyPath</span>(<span class="hljs-params">self, path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 创建一个栈</span><br>    stack = []<br>    <span class="hljs-comment"># 首先去掉多余的/</span><br>    <span class="hljs-comment"># 使用正则表达式进行匹配</span><br>    path = re.sub(<span class="hljs-string">r&#x27;/+&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, path)<br>    <span class="hljs-comment"># 将path转换成数组</span><br>    paths = path.split(<span class="hljs-string">&#x27;/&#x27;</span>)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> paths:<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> item == <span class="hljs-string">&#x27;&#x27;</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;..&#x27;</span>:<br>            <span class="hljs-keyword">if</span> stack:<br>                stack.pop()<br>            <span class="hljs-keyword">continue</span><br>        stack.append(item)<br>    <span class="hljs-comment"># 不需要对字符串进行翻转</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-string">&#x27;/&#x27;</span>.join(stack)<br></code></pre></td></tr></table></figure>
<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 用一个变量维护最小值的方式不太可取，因为pop时总是需要找到下一个最小值，是否能够满足在常数时间复杂度内完成这个操作</span><br>        <span class="hljs-comment"># 但是可以创一个辅助的栈来帮助我们完成</span><br>        self.stack = []<br>        self.minStack = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 常规push</span><br>        self.stack.append(val)<br>        <span class="hljs-comment"># 最小栈的维护</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.minStack <span class="hljs-keyword">or</span> val &lt;= self.minStack[-<span class="hljs-number">1</span>]:<br>            self.minStack.append(val)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 为什么要再次加入最小元素</span><br>            <span class="hljs-comment"># 因为始终保持了同步</span><br>            self.minStack.append(self.minStack[-<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.stack.pop()<br>        self.minStack.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> self.minStack[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用最少数量的箭引爆气球</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findMinArrowShots</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 感觉这个题也是合并区间</span><br>    <span class="hljs-comment"># 找到最后不能合并的区间的个数</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> points:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    nums = <span class="hljs-built_in">len</span>(points)<br>    <span class="hljs-comment"># 注意:由于至少需要一只箭,所以初始化为1</span><br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 首先points按照第一个元素的顺序排序</span><br>    points.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>    <span class="hljs-comment"># 然后遍历point</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 可以只记录一个end即可</span><br>    end = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(points)):<br>        <span class="hljs-keyword">if</span> points[i][<span class="hljs-number">0</span>] &gt; end:<br>            res += <span class="hljs-number">1</span><br>            end = points[i][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure>
<h3 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 插入区间</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], newInterval: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    res = []<br>    i = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(intervals) <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>]:<br>        res.append(intervals[i])<br>        i += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(intervals) <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>]:<br>        newInterval = [<span class="hljs-built_in">min</span>(newInterval[<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">0</span>]),<br>                       <span class="hljs-built_in">max</span>(newInterval[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>])]<br>        i += <span class="hljs-number">1</span><br>    res.append(newInterval)<br><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(intervals):<br>        res.append(intervals[i])<br>        i += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="🌟76-最小覆盖子串"><a href="#🌟76-最小覆盖子串" class="headerlink" title="🌟76. 最小覆盖子串"></a>🌟<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最小覆盖子串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minWindow</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> t:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment"># 创建字典记录字母的出现次数</span><br>    tDict = Counter(t)<br><br>    <span class="hljs-comment"># 创建滑动窗口的边界</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># formed 用于记录当前窗口中满足 t_dict 条件的字符数</span><br>    formed = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 需要满足的字符数</span><br>    required = <span class="hljs-built_in">len</span>(tDict)<br><br>    windowDict = &#123;&#125;<br><br>    <span class="hljs-comment"># ans 用于记录最小覆盖子串的位置信息和长度</span><br>    <span class="hljs-comment"># (子串长度, 左边界索引, 右边界索引)</span><br>    ans = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>), <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">while</span> right &lt; <span class="hljs-built_in">len</span>(s):<br><br>        character = s[right]<br>        windowDict[character] = windowDict.get(character, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> character <span class="hljs-keyword">in</span> tDict <span class="hljs-keyword">and</span> windowDict[character] == tDict[character]:<br>            formed += <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 缩小滑动窗口</span><br>        <span class="hljs-keyword">while</span> left &lt;= right <span class="hljs-keyword">and</span> formed == required:<br>            character = s[left]<br>            <span class="hljs-comment"># 判断是否更新答案</span><br>            <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> &lt; ans[<span class="hljs-number">0</span>]:<br>                ans = (right - left + <span class="hljs-number">1</span>, left, right)<br>            windowDict[character] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> character <span class="hljs-keyword">in</span> tDict <span class="hljs-keyword">and</span> windowDict[character] &lt; tDict[character]:<br>                formed -= <span class="hljs-number">1</span><br>            left += <span class="hljs-number">1</span><br>        right += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">if</span> ans[<span class="hljs-number">0</span>] == <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">else</span> s[ans[<span class="hljs-number">1</span>]:ans[<span class="hljs-number">2</span>]+<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="🌟30-串联所有单词的子串"><a href="#🌟30-串联所有单词的子串" class="headerlink" title="🌟30. 串联所有单词的子串"></a>🌟<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 串联所有单词的子串</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> words <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> s:<br>        <span class="hljs-keyword">return</span> []<br>    <span class="hljs-comment"># 每个单词的长度都是相同的</span><br>    wordLen = <span class="hljs-built_in">len</span>(words[<span class="hljs-number">0</span>])<br>    wordCount = <span class="hljs-built_in">len</span>(words)<br>    totalLen = wordLen * wordCount<br>    <span class="hljs-comment"># 使用哈希表存储words中单词的出现次数</span><br>    wordFreq = Counter(words)<br>    <span class="hljs-comment"># 结果列表</span><br>    indices = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(wordLen):<br>        left = i<br>        right = i<br>        currentFreq = Counter()<br><br>        <span class="hljs-keyword">while</span> right + wordLen &lt;= <span class="hljs-built_in">len</span>(s):<br>            word = s[right:right + wordLen]<br>            right += wordLen<br>            <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> wordFreq:<br>                currentFreq[word] += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 如果当前单词频率超过所需频率，则移动左指针直到频率正常</span><br>                <span class="hljs-keyword">while</span> currentFreq[word] &gt; wordFreq[word]:<br>                    leftWord = s[left:left + wordLen]<br>                    currentFreq[leftWord] -= <span class="hljs-number">1</span><br>                    left += wordLen<br>                <span class="hljs-keyword">if</span> right - left == totalLen:<br>                    indices.append(left)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 当前单词不在 word_freq 中，重置 left 和 current_freq</span><br>                currentFreq.clear()<br>                left = right<br>    <span class="hljs-keyword">return</span> indices<br></code></pre></td></tr></table></figure>
<h3 id="🌟373-查找和最小的-K-对数字"><a href="#🌟373-查找和最小的-K-对数字" class="headerlink" title="🌟373. 查找和最小的 K 对数字"></a>🌟<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a></h3><ul>
<li>使用堆</li>
<li>掌握的不是很牢，需要巩固<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查找和最小的 K 对数字</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kSmallestPairs</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 不会做，抄一下</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums1 <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> nums2:<br>        <span class="hljs-keyword">return</span> []<br><br>    minHeap = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(k, <span class="hljs-built_in">len</span>(nums1))):<br>        heapq.heappush(minHeap, (nums1[i]+nums2[<span class="hljs-number">0</span>], i, <span class="hljs-number">0</span>))<br><br>    result = []<br><br>    <span class="hljs-keyword">while</span> k &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> minHeap:<br>        sumVal, i, j = heapq.heappop(minHeap)<br>        result.append([nums1[i], nums2[j]])<br><br>        <span class="hljs-keyword">if</span> j + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(nums2):<br>            heapq.heappush(minHeap, (nums1[i]+nums2[j + <span class="hljs-number">1</span>], i, j+<span class="hljs-number">1</span>))<br>        k -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数组中的第K个最大元素</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 获取第k大的元素，一个符合直觉的方法就是排序</span><br>    <span class="hljs-comment"># 但是这个是在 堆 这个系列里面的</span><br>    <span class="hljs-comment"># 说明如果使用排序</span><br>    <span class="hljs-comment"># 肯定会超过时间</span><br>    <span class="hljs-comment"># 而且存在问题,因为可能有重复元素(这个题似乎没有这个限制)</span><br>    nums.sort(reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> nums[k-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 定义一个最小堆</span><br>    heap = []<br>    <span class="hljs-comment"># 维护一个包含k个元素的最小堆</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>        heapq.heappush(heap, num)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heap) &gt; k:<br>            heapq.heappop(heap)<br>    <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>
<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最长递增子序列</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 创建dp数组</span><br>    <span class="hljs-comment"># 由于输出的是最长递增子序列的长度，所以dp数组表示的含义是到第i个字符时的序列长度</span><br>    dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-comment"># 这里存在一个问题，就是没有比较i之前的所有元素</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 最后返回的应该是dp子数组的最大值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure>
<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3><ul>
<li>普通dp<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打家劫舍</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 首先创建dp数组</span><br>    dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 在计算 dp[1] 的值时，您应该考虑抢第一家和不抢第一家、</span><br>    <span class="hljs-comment"># 只抢第二家之间的选择，即 dp[1] 应该是 nums[0] 和 nums[1] 中的较大者，</span><br>    <span class="hljs-comment"># 而不是直接赋值 nums[1]</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li>
<li>状态压缩dp<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用状态压缩进行优化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 创建两个状态</span><br>    prev, cur = nums[<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-comment"># 先保存好cur</span><br>        temp = cur<br>        cur = <span class="hljs-built_in">max</span>(cur, nums[i] + prev)<br>        prev = temp<br>    <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搜索二维矩阵</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 目前的思路是将二维数组展平，然后用二分查找的方法</span><br>    rows, cols = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment"># 对于一个元素i、j来说有这样的关系</span><br>    <span class="hljs-comment"># 一维表示i * rows + cols</span><br>    <span class="hljs-comment"># 那么反过来也是可以找到二维数组的索引的</span><br>    left, right = <span class="hljs-number">0</span>, rows * cols - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt;= right:<br>        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span><br>        x, y = <span class="hljs-built_in">divmod</span>(mid, cols)<br>        <span class="hljs-keyword">if</span> matrix[x][y] == target:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> matrix[x][y] &lt; target:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h3 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 寻找峰值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 使用二分查找加速</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]:<br>            right = mid<br>        <span class="hljs-keyword">else</span>:<br>            left = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> left<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 首先写一个简单的算法</span><br>    <span class="hljs-comment"># 遍历数组，找到第一个峰值元素</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i+<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">elif</span> i == <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[i] &gt; nums[i+<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure>
<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h3><ul>
<li>链表中点的寻找</li>
<li>实际上是对链表进行归并排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 排序链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 使用快慢指针技术来找到链表的中点</span><br>    <span class="hljs-comment"># 利用他们的速度是二倍的关系</span><br>    <span class="hljs-comment"># 奇数：fast == end slow == mid</span><br>    <span class="hljs-comment"># 偶数：fast == end + 1 slow == mid</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>        <span class="hljs-keyword">return</span> head<br><br>    slow, fast = head, head.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>        fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        slow = slow.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-comment"># 切分</span><br>    <span class="hljs-comment"># 解耦链表</span><br>    mid, slow.<span class="hljs-built_in">next</span> = slow.<span class="hljs-built_in">next</span>, <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 递归的机型排序</span><br>    left, right = self.sortList(head), self.sortList(mid)<br><br>    <span class="hljs-keyword">return</span> self.merge(left, right)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:<br>    dummy = ListNode()<br>    tail = dummy<br><br>    <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:<br>        <span class="hljs-keyword">if</span> l1.val &lt; l2.val:<br>            tail.<span class="hljs-built_in">next</span>, l1 = l1, l1.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">else</span>:<br>            tail.<span class="hljs-built_in">next</span>, l2 = l2, l2.<span class="hljs-built_in">next</span><br>        tail = tail.<span class="hljs-built_in">next</span><br><br>    tail.<span class="hljs-built_in">next</span> = l1 <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> l2<br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><ul>
<li>递归程序的编写<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将有序数组转换为二叉搜索树</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedArrayToBST</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>    <span class="hljs-comment"># 这个题目就是很经典的分治算法</span><br>    <span class="hljs-comment"># 由于是排好序的数组，所以可以直接二分，进行树的构建</span><br>    <span class="hljs-comment"># 先找mid值</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    mid = <span class="hljs-built_in">len</span>(nums) // <span class="hljs-number">2</span><br>    root = TreeNode(nums[mid])<br>    root.left = self.sortedArrayToBST(nums=nums[<span class="hljs-number">0</span>:mid])<br>    <span class="hljs-comment"># nums[mid+1:-1] 从索引 mid+1 处开始截取，但是最后一个元素（索引为 -1 的那个元素）不包括在内。</span><br>    <span class="hljs-comment"># 列表的切片操作是左闭右开的，因此 -1 表示停在倒数第一个元素之前。</span><br>    root.right = self.sortedArrayToBST(nums=nums[mid+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最小路径和</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathSum</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 按照直觉，这个也可以直接对原始数组进行操作</span><br>    rows, cols = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># 按行进行更新</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>            <span class="hljs-keyword">if</span> row == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> col != <span class="hljs-number">0</span>:<br>                    grid[row][col] += grid[row][col-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> col == <span class="hljs-number">0</span>:<br>                grid[row][col] += grid[row-<span class="hljs-number">1</span>][col]<br>                <span class="hljs-keyword">continue</span><br><br>            grid[row][col] += <span class="hljs-built_in">min</span>(grid[row][col-<span class="hljs-number">1</span>], grid[row-<span class="hljs-number">1</span>][col])<br>    <span class="hljs-keyword">return</span> grid[rows-<span class="hljs-number">1</span>][cols-<span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure>
<h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和</a></h3><ul>
<li>经典动态规划问题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 三角形最小路径和</span><br><span class="hljs-comment"># 二维动态规划</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumTotal</span>(<span class="hljs-params">self, triangle: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 自底向上更新triangle数组，这样能够节省空间</span><br>    n = <span class="hljs-built_in">len</span>(triangle)<br>    <span class="hljs-comment"># 注意：最后一行不需要更新，所以起始是n-1行</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(triangle[row])):<br>            triangle[row][col] += <span class="hljs-built_in">min</span>(triangle[row+<span class="hljs-number">1</span>]<br>                                      [col], triangle[row+<span class="hljs-number">1</span>][col+<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬楼梯</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 创建dp数组</span><br>    dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 初始化dp数组</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>        dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure>
<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h3><ul>
<li>注意右边边界的初始索引应该是length - 1<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搜索插入位置</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    mid = (left + right) &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt;= right:<br>        <span class="hljs-keyword">if</span> nums[mid] &lt; target:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> nums[mid] &gt; target:<br>            right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> nums[mid] == target:<br>            <span class="hljs-keyword">return</span> mid<br>        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数</a></h3><ul>
<li>利用位检查或者位消除法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 位检查</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 每次右移一位</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n:<br>        <span class="hljs-comment"># 这里是按位与，1 的前面部分都是0</span><br>        count += n &amp; <span class="hljs-number">1</span><br>        n = n &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br><span class="hljs-comment"># 位清除</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 利用n &amp; n-1去清除最低位的1</span><br>    <span class="hljs-comment"># 可以用这个方法来统计有多少个1（有多少1就要操作多少次）</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n:<br>        n = n &amp; (n-<span class="hljs-number">1</span>)<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/">201. 数字范围按位与</a></h3><ul>
<li>这个题目的解题角度比较刁钻</li>
<li>例如两个数11100b和11011b两个数</li>
<li>他们有公共的前缀11，而一个连续的数值区间，一定会有后面的值为0的数，所以按位与之后的结果就是11000b</li>
<li>那么就变得简单了，只需要记录下向右移动的次数，和最后剩下的前缀，就可以恢复得到最后的结果，bingo~<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数字范围按位与</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rangeBitwiseAnd</span>(<span class="hljs-params">self, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个代码理解起来有点复杂</span><br>    shift = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 找到共同前缀（移动的部分，至少有一个位为0，所以可以直接忽略）</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        left &gt;&gt;= <span class="hljs-number">1</span><br>        right &gt;&gt;= <span class="hljs-number">1</span><br>        shift += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 恢复结果（因为向右边移动了）</span><br>    <span class="hljs-keyword">return</span> left &lt;&lt; shift<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h3><ul>
<li>简单的方法：哈希表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 看上去可以用哈希表解决</span><br>    numDict = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        numDict[nums[i]] = numDict.get(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 获取只出现了一次的数字</span><br>    keys = [key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> numDict.items() <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> keys[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li>
<li>高效的办法：异或运算的性质<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 利用异或运算快速操作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 利用一个数如果与自身异或的结果是0</span><br>    <span class="hljs-comment"># 0与任何数的异或结果都是那个数</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>        res ^= num<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a></h3><ul>
<li>简单的方法：哈希表</li>
<li>高效的办法：32位统计每一位出现的次数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只出现一次的数字 II</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目可以换一种方式来思考</span><br>    <span class="hljs-comment"># 首先转换成二进制的位</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-comment"># 检查第i位是否位1</span><br>            <span class="hljs-comment"># 1 &lt;&lt; i表示将1左移i位，即在第i位上的值为1，其他位上的值为0。然后，我们用这个值和num做与操作，如果结果不为0，表明num在第i位上的值为1。</span><br>            <span class="hljs-keyword">if</span> num &amp; (<span class="hljs-number">1</span> &lt;&lt; i):<br>                count += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 对3取余</span><br>        <span class="hljs-comment"># 主要是为了正确设置结果的值</span><br>        res |= (count % <span class="hljs-number">3</span>) &lt;&lt; i <br>    <span class="hljs-comment"># 处理负数</span><br>    <span class="hljs-comment"># 实际上不是32位的，但是人为限定成了32位</span><br>    <span class="hljs-keyword">if</span> res &gt;= <span class="hljs-number">2</span>**<span class="hljs-number">31</span>:<br>        res -= <span class="hljs-number">2</span>**<span class="hljs-number">32</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
<li>超高效的办法：使用真值表求数字电路的表达式（饶了我吧）</li>
</ul>
<h3 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-bits/">190. 颠倒二进制位</a></h3><ul>
<li>一种低效的算法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 把数字转换成二进制字符串，去除0b</span><br>    binN = <span class="hljs-built_in">bin</span>(n)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">32</span>)<br>    <span class="hljs-comment"># 翻转二进制字符串</span><br>    <span class="hljs-comment"># 切片操作的格式是 [start:stop:step]</span><br>    reverseBinN = binN[::-<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 转换成整数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(reverseBinN, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></li>
<li>一种高效的算法：分组位翻转算法（解释见[[分组位翻转算法]]）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBits</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    n = (n &gt;&gt; <span class="hljs-number">16</span>) | (n &lt;&lt; <span class="hljs-number">16</span>)<br>    n = ((n &amp; <span class="hljs-number">0xff00ff00</span>) &gt;&gt; <span class="hljs-number">8</span>) | ((n &amp; <span class="hljs-number">0x00ff00ff</span>) &lt;&lt; <span class="hljs-number">8</span>)<br>    n = ((n &amp; <span class="hljs-number">0xf0f0f0f0</span>) &gt;&gt; <span class="hljs-number">4</span>) | ((n &amp; <span class="hljs-number">0x0f0f0f0f</span>) &lt;&lt; <span class="hljs-number">4</span>)<br>    n = ((n &amp; <span class="hljs-number">0xcccccccc</span>) &gt;&gt; <span class="hljs-number">2</span>) | ((n &amp; <span class="hljs-number">0x33333333</span>) &lt;&lt; <span class="hljs-number">2</span>)<br>    n = ((n &amp; <span class="hljs-number">0xaaaaaaaa</span>) &gt;&gt; <span class="hljs-number">1</span>) | ((n &amp; <span class="hljs-number">0x55555555</span>) &lt;&lt; <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> n<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-binary/">67. 二进制求和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二进制求和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addBinary</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">str</span>, b: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 创建结果字符串</span><br>    res = <span class="hljs-string">&#x27;&#x27;</span><br>    lenA, lenB = <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(b)<br>    <span class="hljs-comment"># 一种简单的思路，为了简化计算，向较短的字符串中添加0</span><br>    <span class="hljs-keyword">if</span> lenA &gt; lenB:<br>        b = <span class="hljs-string">&#x27;0&#x27;</span> * (lenA - lenB) + b<br>    <span class="hljs-keyword">else</span>:<br>        a = <span class="hljs-string">&#x27;0&#x27;</span> * (lenB - lenA) + a<br>    <span class="hljs-comment"># 进位</span><br>    carry = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>(lenA,lenB) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span> , -<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">sum</span> = carry + <span class="hljs-built_in">int</span>(a[i]) + <span class="hljs-built_in">int</span>(b[i])<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> == <span class="hljs-number">2</span>:<br>            carry = <span class="hljs-number">1</span><br>            res = <span class="hljs-string">&#x27;0&#x27;</span> + res<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> == <span class="hljs-number">3</span>:<br>            carry = <span class="hljs-number">1</span><br>            res = <span class="hljs-string">&#x27;1&#x27;</span> + res<br>        <span class="hljs-keyword">else</span>:<br>            carry = <span class="hljs-number">0</span><br>            res = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">sum</span>) + res<br>    <span class="hljs-keyword">if</span> carry == <span class="hljs-number">1</span>:<br>        res = <span class="hljs-string">&#x27;1&#x27;</span> + res<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h3><ul>
<li>这个题目是一个比较经典的回溯算法题目</li>
<li>两个条件</li>
<li>（括号的数量如果小于n，说明可以再加</li>
<li>）括号的数量如果小于左括号，说明可以再加</li>
<li>终止条件：当括号字符串的长度&#x3D;2 * n<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 伪代码(默写复习)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xxx</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>	res = []<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">s, left, right</span>):<br>		<span class="hljs-keyword">if</span> s == <span class="hljs-number">2</span> * n:<br>			res.append(s)<br>			<span class="hljs-keyword">return</span><br>		<span class="hljs-keyword">if</span> left &lt; n:<br>			backTrack(s+<span class="hljs-string">&#x27;(&#x27;</span>, left + <span class="hljs-number">1</span>, right)<br>		<span class="hljs-keyword">if</span> right &lt; left:<br>			backTrack(s+<span class="hljs-string">&#x27;)&#x27;</span>, left, right + <span class="hljs-number">1</span>)<br>	backTrack(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>	<span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
<li>代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>    <span class="hljs-comment"># 使用回溯法解决问题</span><br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">2</span> * n:<br>            res.append(s)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 如果左边括号未达到n个，说明还能再加括号</span><br>        <span class="hljs-keyword">if</span> left &lt; n:<br>            backTrack(s + <span class="hljs-string">&quot;(&quot;</span>, left + <span class="hljs-number">1</span>, right)<br>        <span class="hljs-comment"># 如果右边括号没有左边的多，说明需要加闭括号</span><br>        <span class="hljs-keyword">if</span> right &lt; left:<br>            backTrack(s + <span class="hljs-string">&quot;)&quot;</span>, left, right + <span class="hljs-number">1</span>)<br><br>    backTrack(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 电话号码的字母组合</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> digits:<br>        <span class="hljs-keyword">return</span> []<br>    <span class="hljs-comment"># 首先创建一个字母和号码的对应表</span><br>    digit2letter = &#123;<br>        <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;abc&quot;</span>,<br>        <span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-string">&quot;def&quot;</span>,<br>        <span class="hljs-string">&quot;4&quot;</span>: <span class="hljs-string">&quot;ghi&quot;</span>,<br>        <span class="hljs-string">&quot;5&quot;</span>: <span class="hljs-string">&quot;jkl&quot;</span>,<br>        <span class="hljs-string">&quot;6&quot;</span>: <span class="hljs-string">&quot;mno&quot;</span>,<br>        <span class="hljs-string">&quot;7&quot;</span>: <span class="hljs-string">&quot;pqrs&quot;</span>,<br>        <span class="hljs-string">&quot;8&quot;</span>: <span class="hljs-string">&quot;tuv&quot;</span>,<br>        <span class="hljs-string">&quot;9&quot;</span>: <span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;<br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, digits: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(digits) == <span class="hljs-number">0</span>:<br>            res.append(s)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> digit2letter[digits[<span class="hljs-number">0</span>]]:<br>            <span class="hljs-comment"># 回溯后面的字符串</span><br>            backTrack(s+letter, digits[<span class="hljs-number">1</span>:])<br><br>    backTrack(<span class="hljs-string">&#x27;&#x27;</span>, digits)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合</a></h3><ul>
<li>4&#x2F;17复习<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 组合</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</span><br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> []<br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">current: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], start: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(current) == k:<br>            <span class="hljs-comment"># 使用切片复制一份</span><br>            res.append(current[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, n + <span class="hljs-number">1</span>):<br>            current.append(i)<br>            backTrack(current, i + <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># 恢复状态</span><br>            current.pop()<br><br>    backTrack([], <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h3><ul>
<li>4&#x2F;17复习 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单词搜索</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exist</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    col, row = <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]), <span class="hljs-built_in">len</span>(board)<br><br>    <span class="hljs-comment"># 定义一下搜索方向</span><br>    direct = [(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)]<br>    <span class="hljs-comment"># 创建visited数组</span><br>    visited = [[<span class="hljs-literal">False</span>] * col <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y, index</span>):<br><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(word):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 判断是否越界</span><br>        <span class="hljs-comment"># 判断条件有点多呀</span><br>        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> x &gt;= row <span class="hljs-keyword">or</span> y &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> y &gt;= col <span class="hljs-keyword">or</span> board[x][y] != word[index] <span class="hljs-keyword">or</span> visited[x][y]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 检查下一个</span><br>        visited[x][y] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> direct:<br>            <span class="hljs-keyword">if</span> dfs(x+item[<span class="hljs-number">0</span>], y+item[<span class="hljs-number">1</span>], index + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        visited[x][y] = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>            <span class="hljs-keyword">if</span> dfs(i, j, <span class="hljs-number">0</span>):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 组合总和</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> candidates:<br>        <span class="hljs-keyword">return</span> []<br><br>    res = []<br>    candidates.sort()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">start, target, path</span>):<br>        <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span>:<br>            res.append(path[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, <span class="hljs-built_in">len</span>(candidates)):<br>            <span class="hljs-keyword">if</span> candidates[i] &gt; target:<br>                <span class="hljs-keyword">break</span><br>            path.append(candidates[i])<br>            backTrack(i, target - candidates[i], path)<br>            path.pop()<br><br>    backTrack(<span class="hljs-number">0</span>, target, [])<br><br>    <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">pass</span><br><br></code></pre></td></tr></table></figure>
<ul>
<li>下面的代码有问题</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下面的代码有问题不能去除重复</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> candidates:<br>        <span class="hljs-keyword">return</span> []<br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">cur, candidates</span>):<br>        <span class="hljs-comment"># 判断是否到了target</span><br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cur:<br>            <span class="hljs-built_in">sum</span> += i<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> == target:<br>            <span class="hljs-keyword">if</span> cur <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res:<br>                res.append(cur[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> &gt; target:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> candidates:<br>                cur.append(i)<br>                backTrack(cur, candidates)<br>                cur.pop()<br>    backTrack([], candidates)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 全排列</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>        <span class="hljs-keyword">return</span> []<br><br>    res = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backTrack</span>(<span class="hljs-params">cur, last</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cur) == <span class="hljs-built_in">len</span>(nums):<br>            res.append(cur[:])<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> last:<br>            cur.append(i)<br>            <span class="hljs-comment"># 回溯</span><br>            nextRemain = last[:]<br>            nextRemain.remove(i)<br>            backTrack(cur, nextRemain)<br>            cur.pop()<br><br>    backTrack([], nums)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除排序链表中的重复元素 II</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 一看就是双指针</span><br>    <span class="hljs-comment"># 创建一个附加头节点</span><br>    dummy = ListNode(-<span class="hljs-number">1</span>,head)<br>    prev = dummy<br>    <span class="hljs-comment"># prev始终是head的前一个结点</span><br>    <span class="hljs-keyword">while</span> head:<br>        <span class="hljs-keyword">if</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> head.val ==head.<span class="hljs-built_in">next</span>.val:<br>            <span class="hljs-comment"># 跳过所有重复节点</span><br>            <span class="hljs-keyword">while</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> head.val == head.<span class="hljs-built_in">next</span>.val:<br>                head = head.<span class="hljs-built_in">next</span> <br>            <span class="hljs-comment"># 再跳一个</span><br>            head = head.<span class="hljs-built_in">next</span><br>            prev.<span class="hljs-built_in">next</span> = head<br>        <span class="hljs-keyword">else</span>:<br>            prev = prev.<span class="hljs-built_in">next</span> <br>            head = head.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>
<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 反转链表 II</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], left: <span class="hljs-built_in">int</span>, right: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> left == right:<br>        <span class="hljs-keyword">return</span> head<br><br>    dummy = ListNode(<span class="hljs-number">0</span>, head)<br>    prev = dummy<br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left - <span class="hljs-number">1</span>):<br>        prev = prev.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-comment"># start</span><br>    start = prev.<span class="hljs-built_in">next</span><br>    then = start.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(right - left):<br>        <span class="hljs-comment"># 反转链表</span><br>        start.<span class="hljs-built_in">next</span> = then.<span class="hljs-built_in">next</span><br>        then.<span class="hljs-built_in">next</span> = prev.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = then<br>        then = start.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br><br></code></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 合并两个有序链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>    <span class="hljs-comment"># 处理空表情况</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> list1:<br>        <span class="hljs-keyword">return</span> list2<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> list2:<br>        <span class="hljs-keyword">return</span> list1<br>    <span class="hljs-comment"># 定义新的链表</span><br>    <span class="hljs-comment"># 定义新的链表的伪头节点</span><br>    dummy = ListNode(-<span class="hljs-number">1</span>)<br>    res = dummy<br><br>    <span class="hljs-comment"># 当两个链表都不为空时，比较当前节点，并连接值较小的节点</span><br>    <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>        <span class="hljs-keyword">if</span> list1.val &lt; list2.val:<br>            res.<span class="hljs-built_in">next</span> = list1<br>            list1 = list1.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">else</span>:<br>            res.<span class="hljs-built_in">next</span> = list2<br>            list2 = list2.<span class="hljs-built_in">next</span><br>        res = res.<span class="hljs-built_in">next</span><br>    <span class="hljs-comment"># 如果某一个链表已为空，直接将非空链表的剩余部分连接到新链表</span><br>    res.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">else</span> list2<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>
<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h3><ul>
<li>4&#x2F;17复习<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 环形链表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 如何检测链表中有没有环</span><br>    <span class="hljs-comment"># 使用快慢指针！一个移动1个，一个移动2个，如果他们总会相遇，则说明有环</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    slow = head<br>    fast = head.<span class="hljs-built_in">next</span>()<br><br>    <span class="hljs-keyword">while</span> slow != fast:<br>        <span class="hljs-comment"># 如果快指针走到头了 说明没必要走了</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> fast <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> fast.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        slow = slow.<span class="hljs-built_in">next</span><br>        fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3><ul>
<li>4&#x2F;17复习</li>
<li>为什么贪心不行？因为可能使用最大的面值最大数量导致最后不够分了，并不是最优解</li>
<li>什么时候贪心可以？<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 零钱兑换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coinChange</span>(<span class="hljs-params">self, coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], amount: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题目一眼动态规划 二眼贪心</span><br><br>    <span class="hljs-comment"># 创建dp数组</span><br>    <span class="hljs-comment"># 含义 要达到i金额最小的硬币数量</span><br>    dp = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * (amount + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 初始化dp数组</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 按照硬币来遍历</span><br>    <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(coin, amount + <span class="hljs-number">1</span>):<br>            dp[x] = <span class="hljs-built_in">min</span>(dp[x], dp[x-coin] + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 最后返回最后一个值</span><br>    <span class="hljs-keyword">return</span> dp[amount] <span class="hljs-keyword">if</span> dp[amount] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h3><ul>
<li>4&#x2F;17复习<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 一个简单的动态规划问题</span><br>    <span class="hljs-comment"># 首先初始化dp数组和dict集合</span><br>    wordSet = <span class="hljs-built_in">set</span>(wordDict)<br>    dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> dp[j] <span class="hljs-keyword">and</span> s[j:i] <span class="hljs-keyword">in</span> wordSet:<br>                dp[i] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br></code></pre></td></tr></table></figure></li>
<li>原始代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单词拆分</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 一个简单的动态规划问题</span><br>    <span class="hljs-comment"># 初始化dp数组</span><br>    <span class="hljs-comment"># 建议将wordDict转换为集合，这样在查找时可以实现更快的操作，集合的查找时间复杂度是O(1)。</span><br>    wordSet = <span class="hljs-built_in">set</span>(wordDict)<br>    dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)<br><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> dp[j] <span class="hljs-keyword">and</span> s[j:i] <span class="hljs-keyword">in</span> wordSet:<br>                dp[i] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 合并区间</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 这个题的目的是合并重叠的区间</span><br>    <span class="hljs-comment"># 感觉可以先对数组进行一次排序，然后再根据情况合并</span><br>    intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])<br>    start, end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    res = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(intervals)):<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &lt;= end:<br>            <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">1</span>] &gt;= end: <br>                end = intervals[i][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            res.append([start, end])<br>            start = intervals[i][<span class="hljs-number">0</span>]<br>            end = intervals[i][<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 对最后一个进行特判</span><br>    res.append([start, end])<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/summary-ranges/">228. 汇总区间</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 汇总区间</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">summaryRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:  <span class="hljs-comment"># 处理空数组</span><br>        <span class="hljs-keyword">return</span> []<br><br>    res = []<br>    start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>  <span class="hljs-comment"># 初始化为第一个元素的下标</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> nums[i] == nums[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>:<br>            end = i  <span class="hljs-comment"># 更新范围的结束</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前数字不是连续的，保存到目前为止的范围</span><br>            <span class="hljs-keyword">if</span> start == end:  <span class="hljs-comment"># 单个元素的范围</span><br>                res.append(<span class="hljs-built_in">str</span>(nums[start]))<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 连续元素的范围</span><br>                res.append(<span class="hljs-built_in">str</span>(nums[start]) + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">str</span>(nums[end]))<br>            start, end = i, i  <span class="hljs-comment"># 更新范围到新的开始地点</span><br><br>    <span class="hljs-comment"># 循环结束后，检查并添加最后一个范围</span><br>    <span class="hljs-keyword">if</span> start == end:  <span class="hljs-comment"># 单个元素的范围</span><br>        res.append(<span class="hljs-built_in">str</span>(nums[start]))<br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 连续元素的范围</span><br>        res.append(<span class="hljs-built_in">str</span>(nums[start]) + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">str</span>(nums[end]))<br><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h3><ul>
<li>这个题目<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 矩阵置零</span><br><span class="hljs-comment"># 性能比较差的解法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 感觉这个题的思路是：先记录下需要改变的行和列，最后统一置0</span><br>    rowSet = <span class="hljs-built_in">set</span>()<br>    colSet = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                rowSet.add(i)<br>                colSet.add(j)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> rowSet:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[item])):<br>            matrix[item][i] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> colSet:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            matrix[j][item] = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h3><ul>
<li>开始想复杂了，实际上比较简单</li>
<li>就是一个转置+水平翻转<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 旋转图像</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 原来旋转=转置+翻转行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>    <span class="hljs-comment"># 翻转行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>        matrix[i].reverse()<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></h3><ul>
<li>两种解法：哈希表（和两数之和有点像）、滑动窗口+set<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 创建一个记录坐标的哈希表</span><br>    posDict = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">in</span> posDict <span class="hljs-keyword">and</span> i - posDict[nums[i]] &lt;= k:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        posDict[nums[i]] = i<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></li>
<li>滑动窗口的解法（很巧妙呀）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 滑动窗口</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    s = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>        <span class="hljs-comment"># 超过窗口就移除之前那个</span><br>        <span class="hljs-keyword">if</span> i &gt; k:<br>            s.remove(nums[i-k-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        s.add(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-pattern/">290. 单词规律</a></h3><ul>
<li>和205简直一模一样</li>
<li>也是需要创建双向映射<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单词规律</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wordPattern</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 创建一个映射哈希表</span><br>    sArr = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    sLen, tLen = <span class="hljs-built_in">len</span>(sArr), <span class="hljs-built_in">len</span>(pattern)<br>    <span class="hljs-keyword">if</span> sLen != tLen:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 创建两个哈希表</span><br>    s2t = &#123;&#125;<br>    t2s = &#123;&#125;<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sLen):<br>        charS, charT = pattern[i], sArr[i]<br><br>        <span class="hljs-keyword">if</span> charS <span class="hljs-keyword">in</span> s2t <span class="hljs-keyword">and</span> s2t[charS] != charT:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> charT <span class="hljs-keyword">in</span> t2s <span class="hljs-keyword">and</span> t2s[charT] != charS:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        s2t[charS] = charT<br>        t2s[charT] = charS<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/isomorphic-strings/">205. 同构字符串</a></h3><ul>
<li>注意读题啊！</li>
<li>首先需要理解什么是同构字符串—两个字符串中的单词映射应当是唯一的，而不是相差的距离一样<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 同构字符串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isIsomorphic</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    sLen, tLen = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(t)<br>    <span class="hljs-keyword">if</span> sLen != tLen:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-comment"># 创建两个哈希表</span><br>    s2t = &#123;&#125;<br>    t2s = &#123;&#125;<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sLen):<br>        charS,charT = s[i],t[i]<br><br>        <span class="hljs-keyword">if</span> charS <span class="hljs-keyword">in</span> s2t <span class="hljs-keyword">and</span> s2t[charS] != charT:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> charT <span class="hljs-keyword">in</span> t2s <span class="hljs-keyword">and</span> t2s[charT] != charS:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        s2t[charS] = charT<br>        t2s[charT] = charS<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h3><ul>
<li>乍一看很简单，两个指针，一个指向s，一个指向t，慢慢遍历。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubsequence</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 创建两个指针分别指向s、t</span><br>    sPointer, tPointer = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> sPointer &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> tPointer &lt; <span class="hljs-built_in">len</span>(t):<br>        <span class="hljs-keyword">if</span> s[sPointer] == t[tPointer]:<br>            sPointer += <span class="hljs-number">1</span><br>            tPointer += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            tPointer += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> sPointer == <span class="hljs-built_in">len</span>(s):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<strong>进阶：</strong><br>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</li>
</ul>
<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h3><ul>
<li>一个非常简单的双指针<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 两数之和 II - 输入有序数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, numbers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-comment"># 感觉可以用双指针</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        <span class="hljs-keyword">if</span> numbers[left] + numbers[right] == target:<br>            <span class="hljs-keyword">return</span> [left+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">elif</span> numbers[left] + numbers[right] &gt; target:<br>            right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="149-直线上最多的点数"><a href="#149-直线上最多的点数" class="headerlink" title="149. 直线上最多的点数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-points-on-a-line/">149. 直线上最多的点数</a></h3><ul>
<li>注意点：斜率的处理（特殊情况、正负数）</li>
<li>思考点：只考虑斜率，不考虑截距不会出问题吗？<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直线上最多的点数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPoints</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 两点确定一条直线，所以可以计算两两之间的斜率？</span><br>    <span class="hljs-comment"># 使用哈希表计算所有可能的斜率？</span><br>    <span class="hljs-comment"># 斜率计算函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getSlope</span>(<span class="hljs-params">p1, p2</span>):<br>        dx, dy = p2[<span class="hljs-number">0</span>] - p1[<span class="hljs-number">0</span>], p2[<span class="hljs-number">1</span>] - p1[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 特殊情况</span><br>        <span class="hljs-comment"># 斜率无穷大</span><br>        <span class="hljs-keyword">if</span> dx == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;inf&#x27;</span><br>        <span class="hljs-comment"># 斜率为0</span><br>        <span class="hljs-keyword">if</span> dy == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 约分，保持精度</span><br>        <span class="hljs-comment"># 同时除以最大公约数</span><br>        d = gcd(dx, dy)<br>        <span class="hljs-comment"># 如果是负数，需要统一，防止-1 / 2 和 1 / -2 不一样</span><br>        <span class="hljs-keyword">if</span> dy &lt; <span class="hljs-number">0</span>:<br>            dy = -dy<br>            dx = -dx<br>        <span class="hljs-keyword">return</span> (dy // d, dx // d)<br><br>    result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(points)):<br>        slopeDict = defaultdict(<span class="hljs-built_in">int</span>)<br>        duplicate = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(points)):<br>            <span class="hljs-keyword">if</span> points[i] == points[j]:<br>                duplicate += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            slope = getSlope(points[i], points[j])<br>            slopeDict[slope] += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 当前的最大值为重复点+max 斜率value</span><br>        result = <span class="hljs-built_in">max</span>(result, (<span class="hljs-built_in">max</span>(slopeDict.values())<br>                     <span class="hljs-keyword">if</span> slopeDict <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + duplicate)<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h3><ul>
<li>找质因子10的个数，转换为2*5的个数，由于5比2的多，所以直接找5的</li>
<li>首先从5开始数，找5的倍数，5的倍数进行分解，看看有多少个因子5<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 阶乘后的零</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">trailingZeroes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 思路很难想到 质因子为10的个数</span><br>    <span class="hljs-comment"># 10 = 2 x 5</span><br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, n + <span class="hljs-number">1</span>, <span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">while</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>            i //= <span class="hljs-number">5</span><br>            ans += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h3><ul>
<li>思路：去除前后空格 -&gt; 翻转整个串  -&gt; 按’ ‘进行split -&gt; 翻转每个单词 -&gt; 重新整合成串<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 反转字符串中的单词</span><br><span class="hljs-comment"># 不优雅版本</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">import</span> re<br>    sPie = re.sub(<span class="hljs-string">r&#x27;\s+&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, s).strip()[::-<span class="hljs-number">1</span>]<br>    sReverse = sPie[::-<span class="hljs-number">1</span>]<br>    sArr = sReverse.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    sArrAfter = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sArr:<br>        sArrAfter.append(i[::-<span class="hljs-number">1</span>])<br>    res = <span class="hljs-string">&#x27; &#x27;</span>.join(sArrAfter)<br>    <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-comment"># 优雅版</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">import</span> re<br>    sPie = re.sub(<span class="hljs-string">r&#x27;\s+&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, s).strip()<br>    word = sPie.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    wordReverse = [item[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> word]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(wordReverse)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></h3><ul>
<li>数组+哈希表</li>
<li>各司其责，主要的难点在于删除</li>
<li>删除的时候，移动要删除的元素到数组末尾，再pop，时间复杂度降到最低！<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># O(1) 时间插入、删除和获取随机元素</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span>:<br>    <span class="hljs-comment"># Your RandomizedSet object will be instantiated and called as such:</span><br>    <span class="hljs-comment"># obj = RandomizedSet()</span><br>    <span class="hljs-comment"># param_1 = obj.insert(val)</span><br>    <span class="hljs-comment"># param_2 = obj.remove(val)</span><br>    <span class="hljs-comment"># param_3 = obj.getRandom()</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 创建数组和哈希表</span><br>        self.numList = []<br>        self.numDict = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 插入元素直接插入到数组</span><br>        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">in</span> self.numDict:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        self.numDict[val] = <span class="hljs-built_in">len</span>(self.numList)<br>        self.numList.append(val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 删除元素比较难</span><br>        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.numDict:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 思路是什么？</span><br>        <span class="hljs-comment"># 将要删那个数变成数组中的最后一个数！~太妙了</span><br>        <span class="hljs-comment"># 获取要删除的值的索引，并将其与列表中的最后一个元素交换</span><br>        index = self.numDict[val]<br>        lastVal = self.numList[-<span class="hljs-number">1</span>]<br>        self.numList[index] = lastVal<br>        self.numDict[lastVal] = index<br>        <span class="hljs-comment"># 删除数组中最后一个元素</span><br>        self.numList.pop()<br>        <span class="hljs-keyword">del</span> self.numDict[val]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRandom</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> random.choice(self.numList)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274. H 指数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/h-index/">274. H 指数</a></h3><ul>
<li>一个朴素的思想<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hIndex</span>(<span class="hljs-params">self, citations: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 看了之后就是先排序</span><br>    citations.sort(reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(citations)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(citations)):<br>        <span class="hljs-comment"># 找到一个index+1 &lt; citations[index]的值</span><br>        <span class="hljs-keyword">if</span> i + <span class="hljs-number">1</span> &gt; citations[i]:<br>            <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(citations)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3><ul>
<li>思考一下我的代码为什么这么拉跨（想必答案就是缺乏思考哈哈哈哈 形成了闭环）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 感觉是找上升序列的问题</span><br>    <span class="hljs-comment"># 找出所有的上升序列即可</span><br>    <span class="hljs-comment"># 标记上升序列的长度</span><br>    start,end = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>    isUp = <span class="hljs-number">0</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>        <span class="hljs-keyword">if</span> prices[i] &gt;= prices[i-<span class="hljs-number">1</span>]:<br>            isUp = <span class="hljs-number">1</span><br>            end += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            res += prices[end] - prices[start]<br>            start = end+<span class="hljs-number">1</span><br>            end = start<br>            isUp = <span class="hljs-number">0</span><br>    res += prices[end] - prices[start]<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
<li>优雅的代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 优雅的代码就是不一样</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    profit = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 遍历价格数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>        <span class="hljs-comment"># 如果今天的价格比昨天高，就认为可以进行一次交易</span><br>        <span class="hljs-keyword">if</span> prices[i] &gt; prices[i-<span class="hljs-number">1</span>]:<br>            profit += prices[i] - prices[i-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> profit<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><ul>
<li>看了以前写的代码写出来了</li>
<li>核心思想是维护两个变量</li>
<li>如果有多只股票呢<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 关键就是遍历与维护变量</span><br>    cost = sys.maxsize<br>    profit = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> prices:<br>        <span class="hljs-keyword">if</span> item &lt; cost:<br>            cost = item<br>        <span class="hljs-keyword">if</span> item - cost &gt; profit:<br>            profit = item - cost<br>    <span class="hljs-keyword">return</span> profit<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和</a></h3><ul>
<li>思考这和传统“三数之和”有什么区别？</li>
<li>本题说明：最后只包含一个解，所以不需要考虑去重<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最接近的三数之和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 三数之和的简化版</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 首先对数组进行排序</span><br>    nums.sort()<br>    minSub = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] - target<br><br>    <span class="hljs-comment"># 首先固定一个元素 然后进行双指针</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        left, right = i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            sumThree = nums[i] + nums[left] + nums[right]<br>            minSub = sumThree-target <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(sumThree - target) &lt;= <span class="hljs-built_in">abs</span>(minSub) <span class="hljs-keyword">else</span> minSub<br>            <span class="hljs-keyword">if</span> sumThree &gt; target:<br>                right -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> sumThree &lt; target:<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> minSub + target<br>    <span class="hljs-keyword">return</span> minSub + target<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配</a></h3><p>这个问题是一个经典的动态规划（Dynamic Programming，DP）问题，你正在尝试实现一个匹配字符串 <code>s</code> 和模式 <code>p</code> 的函数。在这种情况下，模式 <code>p</code> 可以包含普通字符和两个特殊字符:</p>
<ol>
<li><code>.</code> - 可以匹配任何单个字符</li>
<li><code>*</code> - 匹配零个或多个前面的那一个元素<br>![[Pasted image 20240402211458.png]]<br>这种情况下：<code>dp[i][j] = dp[i-2][j]</code><br>![[Pasted image 20240402211440.png]]<br>这种情况下：<code>dp[i][j] = dp[i][j-1]</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    l1, l2 = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br>    dp = [[<span class="hljs-literal">False</span>] * (l1+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l2+<span class="hljs-number">1</span>)]<br>    <span class="hljs-comment"># 初始化dp数组</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, l2+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> p[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>            dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 开始dp过程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l1+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> p[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                <span class="hljs-keyword">if</span> p[i-<span class="hljs-number">2</span>] == s[j-<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> p[i-<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>:<br>                    <span class="hljs-comment"># a * 出现1次或多次</span><br>                    dp[i][j] = dp[i][j-<span class="hljs-number">1</span>]<br>                <span class="hljs-comment"># a * 可匹配0次</span><br>                <span class="hljs-comment"># 如果之前 dp[i][j] 已经是 True，或者如果消掉 *（和它前面的字符）后能够匹配 (dp[i-2][j] 是 True), 那么 dp[i][j] 应该为 True</span><br>                <span class="hljs-comment"># 等价于dp[i][j] = dp[i][j] or dp[i-2][j]</span><br>                dp[i][j] |= dp[i-<span class="hljs-number">2</span>][j]<br>            <span class="hljs-keyword">elif</span> p[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> p[i-<span class="hljs-number">1</span>] == s[j-<span class="hljs-number">1</span>]:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[l2][l1]<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></h3><ul>
<li>简单题</li>
<li>注意边界条件的判定<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonPrefix</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> strs:  <span class="hljs-comment"># 检查 strs 是否为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(strs[<span class="hljs-number">0</span>])):<br>        cur = strs[<span class="hljs-number">0</span>][i]<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> strs[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-comment"># 需要判断长度是否合适</span><br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(item) <span class="hljs-keyword">or</span> item[i] != cur:<br>                <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>][: i]<br>    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h3><ul>
<li>一步一步递推的公式<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15h411Z7Qd/?spm_id_from=333.337.search-card.all.click&vd_source=d9475db036bd1ced8053fd2ce6353ceb">编辑距离 - 动态规划解法 Edit Distance - Dynamic Programming_哔哩哔哩_bilibili</a><br>![[Pasted image 20240401142732.png]]</li>
<li>注意：<br><code>dp = [[0] * l1] * l2</code><br>这行代码创建了一个二维数组 <code>dp</code>，但方式不正确。因为 <code>[[0] * l1] * l2</code> 这种方式复制的是同一个列表的引用。当你修改任意一个 <code>dp[j][i]</code> 的值时，<code>dp</code> 的每一行都会被改变，因为它们实际上是同一个列表的引用。<br>应该用这个<code>dp = [[0] * l1 for _ in range(l2)]</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 创建dp数组</span><br>    l1, l2 = <span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span><br><br>    dp = [[<span class="hljs-number">0</span>] * l1 <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l2)]<br>    <span class="hljs-comment"># 初始化dp数组的第一行和第一列</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l1):<br>        dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2):<br>        dp[j][<span class="hljs-number">0</span>] = dp[j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 进行dp</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l1):<br>            <span class="hljs-comment"># 这里需要考虑边界条件，因为i和j包含了空字符串的情况，因此需要-1</span><br>            <span class="hljs-keyword">if</span> word2[i-<span class="hljs-number">1</span>] == word1[j-<span class="hljs-number">1</span>]:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 两个不相同</span><br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i]<br>                               [j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> dp[l2-<span class="hljs-number">1</span>][l1-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h3><ul>
<li>左右数组进行分别遍历<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    left, right = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(height), [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(height)<br>    <span class="hljs-comment"># 首先遍历左边，看左边的最大高度</span><br>    maxLeft = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(height)):<br>        <span class="hljs-keyword">if</span> maxLeft &lt; height[i - <span class="hljs-number">1</span>]:<br>            maxLeft = height[i - <span class="hljs-number">1</span>]<br>        left[i] = maxLeft<br>    maxRight = height[<span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(height) - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> maxRight &lt; height[j + <span class="hljs-number">1</span>]:<br>            maxRight = height[j + <span class="hljs-number">1</span>]<br>        right[j] = maxRight<br><br>    <span class="hljs-comment"># 遍历</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span>):<br>        res += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(right[k], left[k]) - height[k])<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
<li>双指针？</li>
</ul>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h3><ul>
<li>这个题目特别的经典</li>
<li>但是我已经忘了怎么做了</li>
<li>参考一下coze的思路</li>
<li>首先进行排序，固定第一个数的index</li>
<li>然后使用双指针l、r对剩下的数进行筛选<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 和为0的话</span><br>    <span class="hljs-comment"># 原地排序</span><br>    nums.sort()<br>    result = []<br>    <span class="hljs-comment"># 我的思路是先固定一个数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">2</span>):<br>        <span class="hljs-comment"># 剩下的就是两数之和问题了</span><br>        <span class="hljs-comment"># 如果不是第一个数</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]:<br>            <span class="hljs-comment"># 跳过重复值</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-comment"># 双指针</span><br>        l, r = i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            total = nums[i] + nums[l] + nums[r]<br>            <span class="hljs-keyword">if</span> total &lt; <span class="hljs-number">0</span>:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> total &gt; <span class="hljs-number">0</span>:<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append([nums[i],nums[l],nums[r]])   <br>                <span class="hljs-comment"># 去重复</span><br>                <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l + <span class="hljs-number">1</span>]: l+=<span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> l&lt; r <span class="hljs-keyword">and</span> nums[r] == nums[r-<span class="hljs-number">1</span>]:r-=<span class="hljs-number">1</span><br>                l+=<span class="hljs-number">1</span><br>                r-=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3083-字符串及其反转中是否存在同一子字符串"><a href="#3083-字符串及其反转中是否存在同一子字符串" class="headerlink" title="3083. 字符串及其反转中是否存在同一子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/existence-of-a-substring-in-a-string-and-its-reverse/">3083. 字符串及其反转中是否存在同一子字符串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubstringPresent</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-comment"># 创建一个set</span><br>    st = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> pairwise(s):<br>        st.add((x, y))<br>        <span class="hljs-keyword">if</span> (y, x) <span class="hljs-keyword">in</span> st:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>

<h3 id="3084-统计以给定字符开头和结尾的子字符串总数"><a href="#3084-统计以给定字符开头和结尾的子字符串总数" class="headerlink" title="3084. 统计以给定字符开头和结尾的子字符串总数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-substrings-starting-and-ending-with-given-character/">3084. 统计以给定字符开头和结尾的子字符串总数</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">countSubstrings</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, c: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 遍历一次 查看c出现的次数</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> item == c:<br>            count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> (count*(count+<span class="hljs-number">1</span>))//<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<h3 id="2697-字典序最小回文串"><a href="#2697-字典序最小回文串" class="headerlink" title="2697. 字典序最小回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lexicographically-smallest-palindrome/">2697. 字典序最小回文串</a></h3><ul>
<li>朴素的想法</li>
<li>实际上不是我的想法，而是灵神的想法哈哈哈<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字典序最小回文串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">makeSmallestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 朴素的想法 使用哈希表 找到出现次数不是单数的（中间的不算）</span><br>    <span class="hljs-comment"># 然而事实证明 想得太复杂了</span><br>    <span class="hljs-comment"># 只需要一次遍历就好了</span><br>    sList = <span class="hljs-built_in">list</span>(s)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) // <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">if</span> sList[i] &gt; sList[<span class="hljs-built_in">len</span>(s) - i - <span class="hljs-number">1</span>]:<br>            sList[i] = sList[<span class="hljs-built_in">len</span>(s) - i - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">elif</span> sList[i] &lt; sList[<span class="hljs-built_in">len</span>(s) - i - <span class="hljs-number">1</span>]:<br>            sList[<span class="hljs-built_in">len</span>(s) - i - <span class="hljs-number">1</span>] = sList[i]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(sList)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2375-根据模式串构造最小数字"><a href="#2375-根据模式串构造最小数字" class="headerlink" title="2375. 根据模式串构造最小数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-smallest-number-from-di-string/">2375. 根据模式串构造最小数字</a></h3><ul>
<li>先回忆一下灵神讲得东西</li>
<li>实际上采用的策略是贪心<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据模式串构造最小数字</span><br><span class="hljs-comment"># 下面是抄的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smallestNumber</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-comment"># 根据灵神的思路</span><br>    n = <span class="hljs-built_in">len</span>(pattern)<br>    <span class="hljs-comment"># digits = &#x27;0123456789&#x27;</span><br>    <span class="hljs-built_in">print</span>(digits)<br>    ans = <span class="hljs-built_in">list</span>(digits[<span class="hljs-number">1</span>:n+<span class="hljs-number">2</span>])<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; n:<br>        <span class="hljs-comment"># 如果处于升序</span><br>        <span class="hljs-keyword">if</span> pattern[i] == <span class="hljs-string">&#x27;I&#x27;</span>:<br>            i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">continue</span><br>        i0 = i<br>        i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> pattern[i] == <span class="hljs-string">&#x27;D&#x27;</span>:<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 反转</span><br>    <br>        ans[i0:i+<span class="hljs-number">1</span>] = ans[i0:i+<span class="hljs-number">1</span>][::-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(ans)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2374-边积分最高的节点"><a href="#2374-边积分最高的节点" class="headerlink" title="2374. 边积分最高的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/node-with-highest-edge-score/">2374. 边积分最高的节点</a></h3><ul>
<li>使用一种优雅的做法（来自灵神）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 边积分最高的节点</span><br><span class="hljs-comment"># 一下子从吊车尾的时空占有情况提升到前面，果然代码还得是要优化啊</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edgeScore</span>(<span class="hljs-params">self, edges: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 定义一个score数组 和 最后的maxKey</span><br>    maxKey,maxVal, score = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, [<span class="hljs-number">0</span>]* <span class="hljs-built_in">len</span>(edges)<br>    <span class="hljs-comment"># 一次遍历搞定</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(edges)):<br>        to = edges[i]<br>        score[to] = score[to] + i<br>        <span class="hljs-keyword">if</span> score[to] &gt; maxVal <span class="hljs-keyword">or</span> (score[to]==maxVal <span class="hljs-keyword">and</span> to &lt; maxKey):<br>            maxKey = to <br>            maxVal = score[to]<br>    <span class="hljs-keyword">return</span> maxKey<br></code></pre></td></tr></table></figure></li>
<li>有点脱裤子放屁的做法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 边积分最高的节点</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edgeScore</span>(<span class="hljs-params">self, edges: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 首先明确边积分的定义:</span><br>    <span class="hljs-comment"># 指向节点i的所有边的起始编号之和</span><br>    <span class="hljs-comment"># 朴素的想法是使用map</span><br>    degree = OrderedDict()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(edges)):<br>        degree[edges[i]] = i + degree.get(edges[i], <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 取最大的key,但是这里的key其实是没有排序的,所以会有问题</span><br>    maxKey = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> degree.keys():<br>        <span class="hljs-keyword">if</span> degree.get(maxKey, -<span class="hljs-number">1</span>) &lt; degree[key] <span class="hljs-keyword">or</span> (degree.get(maxKey, -<span class="hljs-number">1</span>) == degree[key] <span class="hljs-keyword">and</span> maxKey &gt; key):<br>            maxKey = key<br><br>    <span class="hljs-keyword">return</span> maxKey<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2373-矩阵中的局部最大值"><a href="#2373-矩阵中的局部最大值" class="headerlink" title="2373. 矩阵中的局部最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-local-values-in-a-matrix/">2373. 矩阵中的局部最大值</a></h3><ul>
<li>实际上就是深度学习中的Maxpooling操作<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 矩阵中的局部最大值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">largestLocal</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-comment"># 基本思想是将每次计算的值放在左上角</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid) - <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid) - <span class="hljs-number">2</span>):<br>            <span class="hljs-comment"># 计算3 * 3矩阵的最大值</span><br>            <span class="hljs-comment"># 请我不要犯傻了，这么简单的问题都要错</span><br>            <span class="hljs-comment"># 首先不要重复使用循环变量♻️</span><br>            <span class="hljs-comment"># 其次，不要只在内层最大值求整行的最大值，而是窗口内的最大值</span><br>            <span class="hljs-comment"># 都没有使用到变量j,怎么会得到正确答案呢?</span><br>            grid[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>([item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> grid[k][j:j+<span class="hljs-number">3</span>]])<br>                             <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, i+<span class="hljs-number">3</span>))<br>        grid[i].pop()<br>        grid[i].pop()<br>    grid.pop()<br>    grid.pop()<br>    <span class="hljs-keyword">return</span> grid<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="200-岛屿数量-1"><a href="#200-岛屿数量-1" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h3><ul>
<li>使用dfs深度优先遍历，本质上是递归<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不含连续1的非负整数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>        <span class="hljs-comment"># 请注意i和j的索引范围，一定要包含等号！！！</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= <span class="hljs-built_in">len</span>(grid) <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            <span class="hljs-keyword">return</span><br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>        dfs(i+<span class="hljs-number">1</span>, j)<br>        dfs(i-<span class="hljs-number">1</span>, j)<br>        dfs(i, j+<span class="hljs-number">1</span>)<br>        dfs(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 如果grid = null直接返回</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-comment"># 这一步会把所有临近的陆地标记成为海洋，一举两得</span><br>                dfs(i, j)<br>                count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h3><ul>
<li>好久没做了，想到了解法的一半（纯纯凭直觉做的）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分发糖果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">candy</span>(<span class="hljs-params">self, ratings: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 看到相邻问题 直接使用左右两个数组</span><br>    <span class="hljs-comment"># 需要注意的是 左右两边只能计算一次 而不能考虑得过于周全</span><br>    <span class="hljs-comment"># 基础糖果数量</span><br>    baseVal = <span class="hljs-built_in">len</span>(ratings)<br>    <span class="hljs-comment"># 由于相邻的两个孩子有一个要求是评分更高的糖果更多</span><br>    left = [<span class="hljs-number">1</span>] * baseVal<br>    right = [<span class="hljs-number">1</span>] * baseVal<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(ratings)):<br>        <span class="hljs-keyword">if</span> ratings[i-<span class="hljs-number">1</span>] &lt; ratings[i]:<br>            left[i] = left[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ratings)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]:<br>            right[i] = right[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, baseVal):<br>        res += <span class="hljs-built_in">max</span>(right[i], left[i])<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
<li>常数级别遍历<br>![[Pasted image 20240323203335.png]]<br>![[Pasted image 20240323203347.png]]<br>需要注意的是，评分相同时，后面的那个孩子应该给1个糖果（因为题目中没有说评分一致时糖果也应该一致），同时增加序列长度的记忆功能，当升降序列长度相等时，应该为降序列再增加一个糖果<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">candy</span>(<span class="hljs-params">self, ratings: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 使用增长序列的方法来做</span><br>    <span class="hljs-comment"># 初始化一些变量</span><br>    length = <span class="hljs-built_in">len</span>(ratings)<br>    dec, inc, pre, res = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length):<br>        <span class="hljs-keyword">if</span> ratings[i] &gt;= ratings[i-<span class="hljs-number">1</span>]:<br>            dec = <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 说明在升序序列</span><br>            pre = pre + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> ratings[i] != ratings[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>            res += pre<br>            <span class="hljs-comment"># 升序序列的长度</span><br>            inc = pre<br>        <span class="hljs-keyword">else</span>:<br>            dec += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dec == inc:<br>                dec += <span class="hljs-number">1</span><br>            res += dec<br>            pre = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="1835-所有数对按位与结果的异或和"><a href="#1835-所有数对按位与结果的异或和" class="headerlink" title="1835. 所有数对按位与结果的异或和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/">1835. 所有数对按位与结果的异或和</a></h3><ul>
<li>优化后的结果（根据分配律进行优化）</li>
<li>a&amp;c ^b&amp;c &#x3D; (a^b) &amp; c<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 考虑优化算法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getXORSum</span>(<span class="hljs-params">self, arr1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], arr2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># a&amp;c ^ b&amp;c = (a^b) &amp; c</span><br>    <span class="hljs-comment"># 根据这个公式</span><br>    a1 = arr1[<span class="hljs-number">0</span>]<br>    a2 = arr2[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 注意边界条件,因为一个数与自己做异或的结果是0,所以一定要注意边界条件</span><br>    <span class="hljs-comment"># 0 位置的已经取出来了,所以需要从1开始</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr1)):<br>        a1 = a1 ^ arr1[i]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr2)):<br>        a2 = a2 ^ arr2[i]<br>    <span class="hljs-keyword">return</span> a1 &amp; a2<br></code></pre></td></tr></table></figure></li>
<li>一个看似正确但是超过内存限制的暴力算法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下面的算法会超过内存限制 gg</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getXORSum</span>(<span class="hljs-params">self, arr1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], arr2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 先写一个试试吧</span><br>    andSum = []<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(arr1)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(arr2)):<br>            andSum.append(arr1[i] &amp; arr2[j])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(andSum)&lt;=<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> andSum[<span class="hljs-number">0</span>]<br>    res = andSum[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(andSum)):<br>        res = res ^ andSum[i]<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="1840-最高建筑高度"><a href="#1840-最高建筑高度" class="headerlink" title="1840. 最高建筑高度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-building-height/">1840. 最高建筑高度</a></h3><ul>
<li>视频讲解<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uQ4y1f7QH/?spm_id_from=333.337.search-card.all.click">LeetCode LeetCode 1840. Maximum Building Height | Weekly Contest 239</a><br>这个题搞了我半天，最主要的其实是最终高度的计算，视频里的点很关键，如果左右两边的限制高度不一样，则可以人为让他们一样，即让少的一个多爬x个，再直接求两个相同高度的限制中的最高高度。</li>
<li>如果两个高度一样<br>![[Pasted image 20240504231729.png]]</li>
<li>如果不一样呢，那就先让两个变得一样，再按上面的方法计算<br>![[Pasted image 20240504231816.png]]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最大建筑高度</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxBuilding</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, restrictions: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 补充额外限制条件</span><br>    restrictions.append([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>    restrictions.append([n, n-<span class="hljs-number">1</span>])<br>    <span class="hljs-comment"># 排序</span><br>    restrictions.sort()<br>    <span class="hljs-comment"># 遍历限制数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        <span class="hljs-comment"># 有如下限制</span><br>        <span class="hljs-comment"># 相邻两个高度差不能超过1</span><br>        <span class="hljs-comment"># 注意：</span><br>        <span class="hljs-comment"># restrictions[i][0] 表示地的编号</span><br>        <span class="hljs-comment"># restrictions[i][1] 表示地的限制高度</span><br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + (restrictions[i][<span class="hljs-number">0</span>] - restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(restrictions)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + (restrictions[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - restrictions[i][<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-comment"># 遍历得到最大高度</span><br>    maxHeight = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        id1, h1 = restrictions[i-<span class="hljs-number">1</span>]<br>        id2, h2 = restrictions[i]<br>        maxHeight = <span class="hljs-built_in">max</span>(maxHeight, (h2 + h1 + id2 - id1)//<span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 可以除2是因为从一个高度到另一个高度可以先上升后下降</span><br>        <span class="hljs-comment"># 来一个形象的例子</span><br>        <span class="hljs-comment">#  / \</span><br>        <span class="hljs-comment"># /   \</span><br>        <span class="hljs-comment">#      \</span><br>    <span class="hljs-keyword">return</span> maxHeight<br></code></pre></td></tr></table></figure></li>
<li>coze写的代码<br>补充说明图片（5.4）<br>![[Pasted image 20240504231444.png]]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxBuilding</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, restrictions: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 这个题不会做啊</span><br>    <span class="hljs-comment"># 只能看题解了</span><br><br>    <span class="hljs-comment"># 首先补充约束条件</span><br>    <span class="hljs-comment"># 第一块地不能修建筑</span><br>    restrictions.append([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># 对建筑进行排序</span><br>    restrictions.sort()<br>    <span class="hljs-comment"># 最后一块地的限制建筑高度(实际没有这个限制,主要是给n-1号用的)</span><br>    restrictions.append([n, n-<span class="hljs-number">1</span>])<br><br>    <span class="hljs-comment"># 从左往右遍历,应用限制</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        <span class="hljs-comment"># 设置restrictions[i][0]块地的限制高度</span><br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] +<br>            restrictions[i][<span class="hljs-number">0</span>]-restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>        )<br>    <span class="hljs-comment"># 从右往左遍历,应用限制(为什么第二个参数是-1？因为0是最后一个需要遍历的值，所以0的下一个就是-1)</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(restrictions)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] +<br>            restrictions[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - restrictions[i][<span class="hljs-number">0</span>]<br>        )<br><br>    <span class="hljs-comment"># 在满足所有限制条件下找最高建筑</span><br>    max_h = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        id1, h1 = restrictions[i - <span class="hljs-number">1</span>]<br>        id2, h2 = restrictions[i]<br>        max_h = <span class="hljs-built_in">max</span>(max_h, (h2 - h1 + id2 - id1) // <span class="hljs-number">2</span> + h1)<br>    <span class="hljs-keyword">return</span> max_h<br></code></pre></td></tr></table></figure></li>
<li>复习写的代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxBuilding</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, restrictions: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 首先添加虚拟建筑</span><br>    restrictions.append([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>    restrictions.append([n, n-<span class="hljs-number">1</span>])<br>    restrictions.sort()<br><br>    <span class="hljs-comment"># 从左到右遍历</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions)):<br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+(restrictions[i][<span class="hljs-number">0</span>]-restrictions[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-comment"># 从右往左遍历</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(restrictions)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        restrictions[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<br>            restrictions[i][<span class="hljs-number">1</span>], restrictions[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+(restrictions[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-restrictions[i][<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-comment"># 找到最大建筑</span><br>    maxHeight = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(restrictions), <span class="hljs-number">1</span>):<br>        index1, height1 = restrictions[i-<span class="hljs-number">1</span>]<br>        index2, height2 = restrictions[i]<br>        maxHeight = <span class="hljs-built_in">max</span>(<br>            maxHeight, ((index2-index1)+(height2-height1))//<span class="hljs-number">2</span>+height1)<br>    <span class="hljs-keyword">return</span> maxHeight<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="670. 最大交换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-swap/">670. 最大交换</a></h3><ul>
<li>5.4复习<br>![[Pasted image 20240504230333.png]]</li>
<li>3.23复习<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 3/23最大交换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumSwap</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 目标：找到x右侧比x大的数</span><br>    <span class="hljs-comment"># 忘了昨天怎么做的了</span><br>    <span class="hljs-comment"># 盲猜从右向左遍历</span><br>    <span class="hljs-comment"># 首先转换int为数组</span><br>    numList = [<span class="hljs-built_in">int</span>(digit) <span class="hljs-keyword">for</span> digit <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(num)]<br>    <span class="hljs-comment"># 记录每个数字最后出现的位置</span><br>    lastSeen = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numList)&#125;<br>    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numList):<br>        <span class="hljs-comment"># 从9-(x+1)的范围内找数,看看是不是在右边,从大往小找</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>, x, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> lastSeen.get(j, -<span class="hljs-number">1</span>) &gt; i:<br>                <span class="hljs-comment"># 说明找到了</span><br>                <span class="hljs-comment"># 交换</span><br>                numList[i], numList[lastSeen.get(<br>                    j)] = numList[lastSeen.get(j)], numList[i]<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, numList)))<br>    <span class="hljs-keyword">return</span> num<br></code></pre></td></tr></table></figure></li>
<li>一种朴素且错误的思维<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个版本有问题</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumSwap</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 一个朴素的想法是把最大的值和第一位交换，得到的总是较大的</span><br>    <span class="hljs-comment"># 遍历一次数组</span><br>    <span class="hljs-comment"># 把num转换成字符串</span><br>    listNum = self.intToList(num)<br>    maxIndex = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(listNum)):<br>        maxIndex = maxIndex <span class="hljs-keyword">if</span> listNum[maxIndex] &gt; listNum[i] <span class="hljs-keyword">else</span> i<br>    <span class="hljs-comment"># swap</span><br>    listNum[<span class="hljs-number">0</span>], listNum[maxIndex] = listNum[maxIndex], listNum[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> self.listToInt(listNum)<br><br><span class="hljs-comment"># 想法果然还是太过于朴素了，因为完全没有考虑到最大的值已经在最高位的情况</span><br><span class="hljs-comment"># 那应该怎么做？把第二大的放到第二位？也不可行，需要考虑的有点多</span><br><span class="hljs-comment"># 比如98368这个数字</span><br><span class="hljs-comment"># 第二大的是8 但是8已经在第2位了</span><br><span class="hljs-comment"># 继续下去？</span><br><span class="hljs-comment"># 复杂度直接进化到O(N^2)了</span><br></code></pre></td></tr></table></figure></li>
<li>我愿称coze为yyds<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 最大交换</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intToList</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>:<br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">int</span>(digit) <span class="hljs-keyword">for</span> digit <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(n)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">listToInt</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, nums)))<br>    <span class="hljs-comment"># coze协作编程代码</span><br>    <span class="hljs-comment"># 方法很巧妙</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumSwap</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 把num转换成数组</span><br>        numList = self.intToList(num)<br>        <span class="hljs-comment"># 记录每个数字最后出现的位置(用了一个字典，如果有重复值，则会更新位置，由于是从前到后遍历，所以可以保证是最后出现的)</span><br>        last = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numList)&#125;<br>        <span class="hljs-comment"># 从左到右遍历数组</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numList):<br>            <span class="hljs-comment"># 从9到x + 1查找可能的最大值（倒序查找，找到x右侧比x大的数）</span><br>            <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>, x, -<span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># 如果找到更大值，并且该更大值的索引在当前索引的右侧</span><br>                <span class="hljs-keyword">if</span> last.get(d, -<span class="hljs-number">1</span>) &gt; i:<br>                    <span class="hljs-comment"># 交换这两个值</span><br>                    numList[i], numList[last[d]] = numList[last[d]], numList[i]<br>                    <span class="hljs-comment"># 由于只允许交换一次，直接返回结果</span><br>                    <span class="hljs-keyword">return</span> self.listToInt(numList)<br>        <span class="hljs-comment"># 如果没有交换发生，直接返回原数</span><br>        <span class="hljs-keyword">return</span> num<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><ul>
<li>错误的双指针法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最大子数组和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 看到题目想到的就是滑动窗口</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 初始化两个指针</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    maxVal = -sys.maxsize - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (right &lt; <span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-comment"># 当前窗口和</span><br>        curVal = self.subArraySum(nums, left, right)<br>        maxVal = maxVal <span class="hljs-keyword">if</span> maxVal &gt;= curVal <span class="hljs-keyword">else</span> curVal<br>        <span class="hljs-comment"># 移动指针</span><br>        <span class="hljs-comment"># 做到这里 感觉好像找不到移动指针的方法了...</span><br>        <span class="hljs-comment"># 但是通过思考发现 好像可以用动态规划</span><br>        right += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li>
<li>正确的动态规划法（卡登算法？）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最大子数组和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 使用动态规划来解决这个问题</span><br>    <span class="hljs-comment"># 首先初始化dp数组</span><br>    dp = [nums[<span class="hljs-number">0</span>]] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="⚠️思考为什么最后一个值不是最大值"><a href="#⚠️思考为什么最后一个值不是最大值" class="headerlink" title="⚠️思考为什么最后一个值不是最大值?"></a>⚠️思考为什么最后一个值不是最大值?</h5><p>因为dp[i]的值是以nums[i]结尾的子数组的最大和，所以并不是全局最大和</p>
<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><p>很简单，注意边界条件需要包含等于，否则只有一个元素的情况下会直接返回-1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        lens = <span class="hljs-built_in">len</span>(nums)<br>        l, r = <span class="hljs-number">0</span>, lens - <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 注意边界条件</span><br>        <span class="hljs-keyword">while</span> (l &lt;= r):<br>            m = (l + r) &gt;&gt; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> nums[m] == target:<br>                <span class="hljs-keyword">return</span> m<br>            <span class="hljs-keyword">elif</span> nums[m] &lt; target:<br>                l = m + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                r = m - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 看到这个题的第一眼就是双指针</span><br><br>        slow, fast = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-comment"># slow指针用来指示目标数组的位置</span><br>        <span class="hljs-comment"># fast指正用来遍历数组，找到目标元素</span><br>        <span class="hljs-keyword">while</span>(fast &lt; l):<br>            <span class="hljs-comment"># 找到了目标元素</span><br>            <span class="hljs-keyword">if</span> nums[fast]==val:<br>                <span class="hljs-comment"># slow指针停在原地，等待找到下一个非目标元素替换掉</span><br>                fast += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 如果不是目标元素</span><br>            <span class="hljs-keyword">else</span>:<br>                nums[slow] = nums[fast]<br>                fast += <span class="hljs-number">1</span><br>                slow += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> slow<br>        <br></code></pre></td></tr></table></figure>
<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 由于数组是有序的，所有可以考虑使用双指针法，从左右两端分别遍历</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        left, right = <span class="hljs-number">0</span>, l - <span class="hljs-number">1</span><br>        result = [<span class="hljs-number">0</span>] * l<br>        index = l - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right):<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(nums[left]) &gt;= <span class="hljs-built_in">abs</span>(nums[right])):<br>                result[index] = (nums[left] * nums[left])<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result[index] = (nums[right] * nums[right])<br>                right -= <span class="hljs-number">1</span><br>            index -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br>        <br></code></pre></td></tr></table></figure>
<h3 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/third-maximum-number/">414. 第三大的数</a></h3><ul>
<li>一种错误的解法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 第三大的数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">thirdMax</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 最简单的方法就是排序之后选第3大的</span><br>        <span class="hljs-comment"># 但是进一步思考，如果只需要第3大的，还需要对所有数组排序吗</span><br>        <span class="hljs-comment"># 看上去是不需要的，因此这里使用冒泡排序找到第三大的即可</span><br>        <span class="hljs-comment"># 时间复杂度O(3N)</span><br>        length = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, length <span class="hljs-keyword">if</span> length &lt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, length):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                    <span class="hljs-comment"># swap</span><br>                    nums[i], nums[j] = nums[j], nums[i]<br>        <span class="hljs-built_in">print</span>(nums)<br>        <span class="hljs-comment"># 事实证明这样的解法是有bug的，因为nums中可能有重复的值，所以还需要进行去重操作</span><br>        <span class="hljs-comment"># 一种想到的思路是维护一个集合，用来去重，但是不如一开始就用集合，所以这样是脱裤子放屁</span><br>        <span class="hljs-keyword">return</span> nums[-<span class="hljs-number">3</span>] <span class="hljs-keyword">if</span> length &gt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> nums[-<span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure></li>
<li>正确的高效解法：运用集合去重（注意事项：边界条件）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">thirdMax</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>  <span class="hljs-comment"># 维护一个集合，使得集合中只有3个数，并且超出时删除最小的</span><br>  s = <span class="hljs-built_in">set</span>()<br>  <span class="hljs-comment"># 遍历数组</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)):<br>    s.add(nums[i])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">3</span>:<br>      <span class="hljs-comment"># 删除集合中最小的值</span><br>      minValue = <span class="hljs-built_in">min</span>(s)<br>      s.remove(minValue)<br>    <span class="hljs-built_in">print</span>(s)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(s) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &gt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">max</span>(s)<br></code></pre></td></tr></table></figure></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" class="print-no-link">#算法学习</a>
      
        <a href="/tags/%E8%AE%A1%E5%88%92/" class="print-no-link">#计划</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法能力提升计划 Algorithm Capability Enhancement Program</div>
      <div>https://yintel12138.github.io/2024/04/01/Algorithm-Improve/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yintel</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/21/mit-6-s081-lab1/" title="mit 6.s081 lab1">
                        <span class="hidden-mobile">mit 6.s081 lab1</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"8gl72LxBS2zmZy6Sw6GG6Uqm-gzGzoHsz","appKey":"npBzZPYqXYhrvnpS8KAH3yDF","path":"window.location.pathname","placeholder":"欢迎大家留言~","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":true},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> <br/> <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span> <br/> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <br/> <span>Yintel Copyright©️2023 - 2024</span>

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
